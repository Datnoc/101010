"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/alpaca/crypto/latest/route";
exports.ids = ["app/api/alpaca/crypto/latest/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&page=%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute.ts&appDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&page=%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute.ts&appDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_emretutkun_Documents_GitHub_101010_app_api_alpaca_crypto_latest_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/alpaca/crypto/latest/route.ts */ \"(rsc)/./app/api/alpaca/crypto/latest/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/alpaca/crypto/latest/route\",\n        pathname: \"/api/alpaca/crypto/latest\",\n        filename: \"route\",\n        bundlePath: \"app/api/alpaca/crypto/latest/route\"\n    },\n    resolvedPagePath: \"/Users/emretutkun/Documents/GitHub/101010/app/api/alpaca/crypto/latest/route.ts\",\n    nextConfigOutput,\n    userland: _Users_emretutkun_Documents_GitHub_101010_app_api_alpaca_crypto_latest_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/alpaca/crypto/latest/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZhbHBhY2ElMkZjcnlwdG8lMkZsYXRlc3QlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmFscGFjYSUyRmNyeXB0byUyRmxhdGVzdCUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmFscGFjYSUyRmNyeXB0byUyRmxhdGVzdCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmVtcmV0dXRrdW4lMkZEb2N1bWVudHMlMkZHaXRIdWIlMkYxMDEwMTAlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGZW1yZXR1dGt1biUyRkRvY3VtZW50cyUyRkdpdEh1YiUyRjEwMTAxMCZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDK0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRwYXkvP2FjZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2VtcmV0dXRrdW4vRG9jdW1lbnRzL0dpdEh1Yi8xMDEwMTAvYXBwL2FwaS9hbHBhY2EvY3J5cHRvL2xhdGVzdC9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvYWxwYWNhL2NyeXB0by9sYXRlc3Qvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9hbHBhY2EvY3J5cHRvL2xhdGVzdFwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvYWxwYWNhL2NyeXB0by9sYXRlc3Qvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvZW1yZXR1dGt1bi9Eb2N1bWVudHMvR2l0SHViLzEwMTAxMC9hcHAvYXBpL2FscGFjYS9jcnlwdG8vbGF0ZXN0L3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9hbHBhY2EvY3J5cHRvL2xhdGVzdC9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&page=%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute.ts&appDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/alpaca/crypto/latest/route.ts":
/*!***********************************************!*\
  !*** ./app/api/alpaca/crypto/latest/route.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_alpaca__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/alpaca */ \"(rsc)/./lib/alpaca.ts\");\n\n\n// Cache için in-memory store\nconst cache = new Map();\nconst CACHE_DURATION = 10000; // 10 saniye (canlı fiyat için daha kısa)\nasync function GET(request) {\n    try {\n        if (!(0,_lib_alpaca__WEBPACK_IMPORTED_MODULE_1__.isAlpacaConfigured)()) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Alpaca yapılandırması eksik\"\n            }, {\n                status: 500\n            });\n        }\n        const { searchParams } = new URL(request.url);\n        let symbol = searchParams.get(\"symbol\");\n        if (!symbol) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Sembol gereklidir\"\n            }, {\n                status: 400\n            });\n        }\n        // Sembolü temizle (boşlukları kaldır, büyük harfe çevir)\n        symbol = symbol.trim().toUpperCase();\n        // Cache key oluştur\n        const cacheKey = `crypto-latest-${symbol}`;\n        const cached = cache.get(cacheKey);\n        // Cache kontrolü (10 saniye içindeyse cache'den dön)\n        if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(cached.data);\n        }\n        try {\n            const tradeData = await (0,_lib_alpaca__WEBPACK_IMPORTED_MODULE_1__.getAlpacaCryptoLatestTrade)(symbol);\n            // Trade data'dan fiyatı al\n            let price = null;\n            if (tradeData && tradeData.trade) {\n                price = parseFloat(tradeData.trade.p);\n            } else if (tradeData && tradeData.price) {\n                price = parseFloat(tradeData.price);\n            } else if (tradeData && typeof tradeData === \"number\") {\n                price = tradeData;\n            }\n            if (price === null || isNaN(price)) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Fiyat bilgisi alınamadı\"\n                }, {\n                    status: 404\n                });\n            }\n            const responseData = {\n                success: true,\n                price: price,\n                symbol: symbol\n            };\n            // Cache'e kaydet\n            cache.set(cacheKey, {\n                data: responseData,\n                timestamp: Date.now()\n            });\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(responseData);\n        } catch (error) {\n            console.error(\"Alpaca crypto latest trade error:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Canlı fiyat alınamadı\",\n                message: error.message || \"Bilinmeyen hata\"\n            }, {\n                status: 500\n            });\n        }\n    } catch (error) {\n        console.error(\"Crypto latest error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Canlı fiyat alınamadı\",\n            message: error.message || \"Bilinmeyen hata\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2FscGFjYS9jcnlwdG8vbGF0ZXN0L3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUNzQjtBQUU5RSw2QkFBNkI7QUFDN0IsTUFBTUcsUUFBUSxJQUFJQztBQUNsQixNQUFNQyxpQkFBaUIsT0FBTyx5Q0FBeUM7QUFFaEUsZUFBZUMsSUFBSUMsT0FBb0I7SUFDNUMsSUFBSTtRQUNGLElBQUksQ0FBQ0wsK0RBQWtCQSxJQUFJO1lBQ3pCLE9BQU9GLHFEQUFZQSxDQUFDUSxJQUFJLENBQ3RCO2dCQUFFQyxPQUFPO1lBQThCLEdBQ3ZDO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxNQUFNLEVBQUVDLFlBQVksRUFBRSxHQUFHLElBQUlDLElBQUlMLFFBQVFNLEdBQUc7UUFDNUMsSUFBSUMsU0FBU0gsYUFBYUksR0FBRyxDQUFDO1FBRTlCLElBQUksQ0FBQ0QsUUFBUTtZQUNYLE9BQU9kLHFEQUFZQSxDQUFDUSxJQUFJLENBQ3RCO2dCQUFFQyxPQUFPO1lBQW9CLEdBQzdCO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSx5REFBeUQ7UUFDekRJLFNBQVNBLE9BQU9FLElBQUksR0FBR0MsV0FBVztRQUVsQyxvQkFBb0I7UUFDcEIsTUFBTUMsV0FBVyxDQUFDLGNBQWMsRUFBRUosT0FBTyxDQUFDO1FBQzFDLE1BQU1LLFNBQVNoQixNQUFNWSxHQUFHLENBQUNHO1FBRXpCLHFEQUFxRDtRQUNyRCxJQUFJQyxVQUFVQyxLQUFLQyxHQUFHLEtBQUtGLE9BQU9HLFNBQVMsR0FBR2pCLGdCQUFnQjtZQUM1RCxPQUFPTCxxREFBWUEsQ0FBQ1EsSUFBSSxDQUFDVyxPQUFPSSxJQUFJO1FBQ3RDO1FBRUEsSUFBSTtZQUNGLE1BQU1DLFlBQVksTUFBTXZCLHVFQUEwQkEsQ0FBQ2E7WUFFbkQsMkJBQTJCO1lBQzNCLElBQUlXLFFBQXVCO1lBRTNCLElBQUlELGFBQWFBLFVBQVVFLEtBQUssRUFBRTtnQkFDaENELFFBQVFFLFdBQVdILFVBQVVFLEtBQUssQ0FBQ0UsQ0FBQztZQUN0QyxPQUFPLElBQUlKLGFBQWFBLFVBQVVDLEtBQUssRUFBRTtnQkFDdkNBLFFBQVFFLFdBQVdILFVBQVVDLEtBQUs7WUFDcEMsT0FBTyxJQUFJRCxhQUFhLE9BQU9BLGNBQWMsVUFBVTtnQkFDckRDLFFBQVFEO1lBQ1Y7WUFFQSxJQUFJQyxVQUFVLFFBQVFJLE1BQU1KLFFBQVE7Z0JBQ2xDLE9BQU96QixxREFBWUEsQ0FBQ1EsSUFBSSxDQUN0QjtvQkFBRUMsT0FBTztnQkFBMEIsR0FDbkM7b0JBQUVDLFFBQVE7Z0JBQUk7WUFFbEI7WUFFQSxNQUFNb0IsZUFBZTtnQkFDbkJDLFNBQVM7Z0JBQ1ROLE9BQU9BO2dCQUNQWCxRQUFRQTtZQUNWO1lBRUEsaUJBQWlCO1lBQ2pCWCxNQUFNNkIsR0FBRyxDQUFDZCxVQUFVO2dCQUNsQkssTUFBTU87Z0JBQ05SLFdBQVdGLEtBQUtDLEdBQUc7WUFDckI7WUFFQSxPQUFPckIscURBQVlBLENBQUNRLElBQUksQ0FBQ3NCO1FBQzNCLEVBQUUsT0FBT3JCLE9BQVk7WUFDbkJ3QixRQUFReEIsS0FBSyxDQUFDLHFDQUFxQ0E7WUFFbkQsT0FBT1QscURBQVlBLENBQUNRLElBQUksQ0FDdEI7Z0JBQ0VDLE9BQU87Z0JBQ1B5QixTQUFTekIsTUFBTXlCLE9BQU8sSUFBSTtZQUM1QixHQUNBO2dCQUFFeEIsUUFBUTtZQUFJO1FBRWxCO0lBQ0YsRUFBRSxPQUFPRCxPQUFZO1FBQ25Cd0IsUUFBUXhCLEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3RDLE9BQU9ULHFEQUFZQSxDQUFDUSxJQUFJLENBQ3RCO1lBQ0VDLE9BQU87WUFDUHlCLFNBQVN6QixNQUFNeUIsT0FBTyxJQUFJO1FBQzVCLEdBQ0E7WUFBRXhCLFFBQVE7UUFBSTtJQUVsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0cGF5Ly4vYXBwL2FwaS9hbHBhY2EvY3J5cHRvL2xhdGVzdC9yb3V0ZS50cz82Y2ZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBnZXRBbHBhY2FDcnlwdG9MYXRlc3RUcmFkZSwgaXNBbHBhY2FDb25maWd1cmVkIH0gZnJvbSAnQC9saWIvYWxwYWNhJztcblxuLy8gQ2FjaGUgacOnaW4gaW4tbWVtb3J5IHN0b3JlXG5jb25zdCBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCB7IGRhdGE6IGFueTsgdGltZXN0YW1wOiBudW1iZXIgfT4oKTtcbmNvbnN0IENBQ0hFX0RVUkFUSU9OID0gMTAwMDA7IC8vIDEwIHNhbml5ZSAoY2FubMSxIGZpeWF0IGnDp2luIGRhaGEga8Sxc2EpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWlzQWxwYWNhQ29uZmlndXJlZCgpKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdBbHBhY2EgeWFwxLFsYW5kxLFybWFzxLEgZWtzaWsnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IHN5bWJvbCA9IHNlYXJjaFBhcmFtcy5nZXQoJ3N5bWJvbCcpO1xuXG4gICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1NlbWJvbCBnZXJla2xpZGlyJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gU2VtYm9sw7wgdGVtaXpsZSAoYm/Fn2x1a2xhcsSxIGthbGTEsXIsIGLDvHnDvGsgaGFyZmUgw6dldmlyKVxuICAgIHN5bWJvbCA9IHN5bWJvbC50cmltKCkudG9VcHBlckNhc2UoKTtcblxuICAgIC8vIENhY2hlIGtleSBvbHXFn3R1clxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGNyeXB0by1sYXRlc3QtJHtzeW1ib2x9YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIFxuICAgIC8vIENhY2hlIGtvbnRyb2zDvCAoMTAgc2FuaXllIGnDp2luZGV5c2UgY2FjaGUnZGVuIGTDtm4pXG4gICAgaWYgKGNhY2hlZCAmJiBEYXRlLm5vdygpIC0gY2FjaGVkLnRpbWVzdGFtcCA8IENBQ0hFX0RVUkFUSU9OKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oY2FjaGVkLmRhdGEpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFkZURhdGEgPSBhd2FpdCBnZXRBbHBhY2FDcnlwdG9MYXRlc3RUcmFkZShzeW1ib2wpO1xuICAgICAgXG4gICAgICAvLyBUcmFkZSBkYXRhJ2RhbiBmaXlhdMSxIGFsXG4gICAgICBsZXQgcHJpY2U6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgXG4gICAgICBpZiAodHJhZGVEYXRhICYmIHRyYWRlRGF0YS50cmFkZSkge1xuICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQodHJhZGVEYXRhLnRyYWRlLnApO1xuICAgICAgfSBlbHNlIGlmICh0cmFkZURhdGEgJiYgdHJhZGVEYXRhLnByaWNlKSB7XG4gICAgICAgIHByaWNlID0gcGFyc2VGbG9hdCh0cmFkZURhdGEucHJpY2UpO1xuICAgICAgfSBlbHNlIGlmICh0cmFkZURhdGEgJiYgdHlwZW9mIHRyYWRlRGF0YSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcHJpY2UgPSB0cmFkZURhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmljZSA9PT0gbnVsbCB8fCBpc05hTihwcmljZSkpIHtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdGaXlhdCBiaWxnaXNpIGFsxLFuYW1hZMSxJyB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA0MDQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHByaWNlOiBwcmljZSxcbiAgICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICB9O1xuXG4gICAgICAvLyBDYWNoZSdlIGtheWRldFxuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihyZXNwb25zZURhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FscGFjYSBjcnlwdG8gbGF0ZXN0IHRyYWRlIGVycm9yOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IFxuICAgICAgICAgIGVycm9yOiAnQ2FubMSxIGZpeWF0IGFsxLFuYW1hZMSxJyxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdCaWxpbm1leWVuIGhhdGEnXG4gICAgICAgIH0sXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdDcnlwdG8gbGF0ZXN0IGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IFxuICAgICAgICBlcnJvcjogJ0NhbmzEsSBmaXlhdCBhbMSxbmFtYWTEsScsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ0JpbGlubWV5ZW4gaGF0YSdcbiAgICAgIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJnZXRBbHBhY2FDcnlwdG9MYXRlc3RUcmFkZSIsImlzQWxwYWNhQ29uZmlndXJlZCIsImNhY2hlIiwiTWFwIiwiQ0FDSEVfRFVSQVRJT04iLCJHRVQiLCJyZXF1ZXN0IiwianNvbiIsImVycm9yIiwic3RhdHVzIiwic2VhcmNoUGFyYW1zIiwiVVJMIiwidXJsIiwic3ltYm9sIiwiZ2V0IiwidHJpbSIsInRvVXBwZXJDYXNlIiwiY2FjaGVLZXkiLCJjYWNoZWQiLCJEYXRlIiwibm93IiwidGltZXN0YW1wIiwiZGF0YSIsInRyYWRlRGF0YSIsInByaWNlIiwidHJhZGUiLCJwYXJzZUZsb2F0IiwicCIsImlzTmFOIiwicmVzcG9uc2VEYXRhIiwic3VjY2VzcyIsInNldCIsImNvbnNvbGUiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/alpaca/crypto/latest/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/alpaca.ts":
/*!***********************!*\
  !*** ./lib/alpaca.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelAlpacaOrder: () => (/* binding */ cancelAlpacaOrder),\n/* harmony export */   closeAlpacaAccount: () => (/* binding */ closeAlpacaAccount),\n/* harmony export */   createAlpacaAccount: () => (/* binding */ createAlpacaAccount),\n/* harmony export */   depositToAlpacaAccount: () => (/* binding */ depositToAlpacaAccount),\n/* harmony export */   findAlpacaAccountByEmail: () => (/* binding */ findAlpacaAccountByEmail),\n/* harmony export */   getAlpacaAccount: () => (/* binding */ getAlpacaAccount),\n/* harmony export */   getAlpacaAccounts: () => (/* binding */ getAlpacaAccounts),\n/* harmony export */   getAlpacaAssets: () => (/* binding */ getAlpacaAssets),\n/* harmony export */   getAlpacaBars: () => (/* binding */ getAlpacaBars),\n/* harmony export */   getAlpacaCryptoBars: () => (/* binding */ getAlpacaCryptoBars),\n/* harmony export */   getAlpacaCryptoLatestTrade: () => (/* binding */ getAlpacaCryptoLatestTrade),\n/* harmony export */   getAlpacaCryptoPositions: () => (/* binding */ getAlpacaCryptoPositions),\n/* harmony export */   getAlpacaLatestTrade: () => (/* binding */ getAlpacaLatestTrade),\n/* harmony export */   getAlpacaMarketCalendar: () => (/* binding */ getAlpacaMarketCalendar),\n/* harmony export */   getAlpacaMarketClock: () => (/* binding */ getAlpacaMarketClock),\n/* harmony export */   getAlpacaOptionQuote: () => (/* binding */ getAlpacaOptionQuote),\n/* harmony export */   getAlpacaOptionTrade: () => (/* binding */ getAlpacaOptionTrade),\n/* harmony export */   getAlpacaOptionsPositions: () => (/* binding */ getAlpacaOptionsPositions),\n/* harmony export */   getAlpacaOrders: () => (/* binding */ getAlpacaOrders),\n/* harmony export */   getAlpacaPortfolioHistory: () => (/* binding */ getAlpacaPortfolioHistory),\n/* harmony export */   getAlpacaPositions: () => (/* binding */ getAlpacaPositions),\n/* harmony export */   getAlpacaQuote: () => (/* binding */ getAlpacaQuote),\n/* harmony export */   isAlpacaConfigured: () => (/* binding */ isAlpacaConfigured),\n/* harmony export */   placeBuyOrder: () => (/* binding */ placeBuyOrder),\n/* harmony export */   placeCryptoOrder: () => (/* binding */ placeCryptoOrder),\n/* harmony export */   placeOptionsOrder: () => (/* binding */ placeOptionsOrder),\n/* harmony export */   placeSellOrder: () => (/* binding */ placeSellOrder),\n/* harmony export */   updateAlpacaAccountPermissions: () => (/* binding */ updateAlpacaAccountPermissions),\n/* harmony export */   withdrawFromAlpacaAccount: () => (/* binding */ withdrawFromAlpacaAccount)\n/* harmony export */ });\n/**\n * Alpaca Markets API Client\n * Alpaca API ile iletişim için yardımcı fonksiyonlar\n */ // Trading API için key'ler (alım-satım, portföy, pozisyon, account data)\nconst ALPACA_API_KEY = process.env.ALPACA_API_KEY || \"\";\nconst ALPACA_SECRET_KEY = process.env.ALPACA_SECRET_KEY || \"\";\nconst ALPACA_BASE_URL = process.env.ALPACA_BASE_URL || \"https://paper-api.alpaca.markets\"; // Paper trading default\n// Broker API için ayrı key'ler (müşteri oluşturma, KYC, hesap açma)\nconst ALPACA_BROKER_API_URL = process.env.ALPACA_BROKER_API_URL || \"https://broker-api.sandbox.alpaca.markets\";\nconst ALPACA_BROKER_API_KEY = process.env.ALPACA_BROKER_API_KEY || process.env.ALPACA_API_KEY || \"\";\nconst ALPACA_BROKER_SECRET_KEY = process.env.ALPACA_BROKER_SECRET_KEY || process.env.ALPACA_SECRET_KEY || \"\";\n// Market Data API için ayrı key'ler ve URL\n// Not: Trading API key'leri Market Data API için de kullanılabilir\n// Market Data API URL'i her zaman https://data.alpaca.markets olmalı\nconst ALPACA_MARKET_DATA_URL = process.env.ALPACA_MARKET_DATA_URL || process.env.NEXT_PUBLIC_ALPACA_DATA_API_URL || \"https://data.alpaca.markets\";\n// Key'ler için fallback: Önce Market Data API key'leri, yoksa Trading API key'leri\nconst ALPACA_MARKET_DATA_API_KEY = process.env.ALPACA_MARKET_API_KEY || process.env.NEXT_PUBLIC_ALPACA_MARKET_API_KEY || process.env.ALPACA_API_KEY || \"\";\nconst ALPACA_MARKET_DATA_SECRET_KEY = process.env.ALPACA_MARKET_SECRET_KEY || process.env.NEXT_PUBLIC_ALPACA_MARKET_SECRET_KEY || process.env.ALPACA_SECRET_KEY || \"\";\n/**\n * Alpaca API'ye istek gönderir\n */ async function alpacaRequest(endpoint, method = \"GET\", body, useBrokerAPI = false, accountId // Opsiyonel: Belirli bir account ID için\n) {\n    // Trading API için v2, Broker API için v1 kullan\n    const baseUrl = useBrokerAPI ? ALPACA_BROKER_API_URL : ALPACA_BASE_URL;\n    const apiKey = useBrokerAPI ? ALPACA_BROKER_API_KEY : ALPACA_API_KEY;\n    const secretKey = useBrokerAPI ? ALPACA_BROKER_SECRET_KEY : ALPACA_SECRET_KEY;\n    const version = useBrokerAPI ? \"v1\" : \"v2\";\n    // Eğer account ID verilmişse ve broker API kullanılıyorsa, endpoint'e ekle\n    let finalEndpoint = endpoint;\n    if (useBrokerAPI) {\n        // Broker API için endpoint yapısı: trading/accounts/{accountId}/...\n        // Eğer endpoint zaten trading/accounts/ ile başlıyorsa, accountId zaten içinde var demektir\n        if (endpoint.startsWith(\"trading/accounts/\")) {\n            // Zaten trading/accounts/{accountId}/ formatında, değiştirme\n            finalEndpoint = endpoint;\n        } else if (accountId) {\n            // trading/accounts/{accountId}/ prefix'i ekle\n            finalEndpoint = `trading/accounts/${accountId}/${endpoint}`;\n        }\n    }\n    const url = `${baseUrl}/${version}/${finalEndpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": apiKey,\n        \"APCA-API-SECRET-KEY\": secretKey,\n        \"Content-Type\": \"application/json\"\n    };\n    // Retry mekanizması ile fetch\n    const fetchWithRetry = async (retries = 3, delay = 1000)=>{\n        for(let i = 0; i < retries; i++){\n            try {\n                const response = await fetch(url, {\n                    method,\n                    headers,\n                    body: body ? JSON.stringify(body) : undefined\n                });\n                return response;\n            } catch (error) {\n                // Network hataları için retry yap (ECONNRESET, fetch failed, vb.)\n                const isNetworkError = error.code === \"ECONNRESET\" || error.message?.includes(\"fetch failed\") || error.message?.includes(\"ECONNRESET\") || error.message?.includes(\"network\") || error.message?.includes(\"timeout\");\n                if (isNetworkError && i < retries - 1) {\n                    console.warn(`Alpaca API network hatası (deneme ${i + 1}/${retries}), ${delay}ms sonra tekrar deneniyor...`);\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                    delay *= 2; // Exponential backoff\n                    continue;\n                }\n                throw error;\n            }\n        }\n        throw new Error(\"Max retry limit reached\");\n    };\n    try {\n        const response = await fetchWithRetry();\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            // Daha açıklayıcı hata mesajları ve detaylı loglama\n            let errorMessage = \"\";\n            let errorDetails = {\n                status: response.status,\n                statusText: response.statusText,\n                url: url,\n                endpoint: endpoint,\n                method: method,\n                apiType: useBrokerAPI ? \"Broker API\" : \"Trading API\",\n                apiKeyPrefix: apiKey ? `${apiKey.substring(0, 8)}...` : \"MISSING\"\n            };\n            if (response.status === 401) {\n                errorMessage = \"Alpaca API kimlik doğrulama hatası. L\\xfctfen API key'lerinizi kontrol edin.\";\n                errorDetails.error = \"Authentication failed\";\n                errorDetails.suggestion = \"API key ve secret key'lerin doğru olduğundan emin olun.\";\n            } else if (response.status === 403) {\n                // 403 hatası için özel kontrol: PDT > options authorization > buying power > permissions\n                const errorMessageLower = errorData.message?.toLowerCase() || \"\";\n                const errorCode = errorData.code;\n                // 1. Önce PDT (Pattern Day Trading) kontrolü - en öncelikli\n                if (errorCode === 40310100 || errorMessageLower.includes(\"pattern day trading\") || errorMessageLower.includes(\"pdt\") || errorMessageLower.includes(\"trade denied due to pattern day trading\")) {\n                    errorMessage = \"Pattern Day Trading (PDT) Koruması: İşlem reddedildi.\";\n                    errorDetails.error = \"Pattern Day Trading Protection\";\n                    errorDetails.suggestion = \"Hesabınızda $25,000'den az bakiye varsa ve 5 iş g\\xfcn\\xfc i\\xe7inde 4 veya daha fazla g\\xfcn-trade yaptıysanız, hesabınız 90 g\\xfcn boyunca kısıtlanır. Hesabınıza $25,000 veya daha fazla para yatırarak bu kısıtlamayı kaldırabilirsiniz.\";\n                    errorDetails.pdtInfo = {\n                        reason: \"Pattern Day Trading koruması aktif\",\n                        solution: \"Hesabınıza $25,000 veya daha fazla para yatırın\",\n                        restriction: \"90 g\\xfcn boyunca g\\xfcn-trade yapamazsınız\"\n                    };\n                } else if (errorMessageLower.includes(\"not authorized to trade options\") || errorMessageLower.includes(\"account not authorized to trade options\") || errorCode === 40310000 && errorMessageLower.includes(\"options\") || errorCode === 40310000 && errorMessageLower.includes(\"authorized\")) {\n                    errorMessage = \"Hesabınız opsiyon işlemleri i\\xe7in yetkilendirilmemiş.\";\n                    errorDetails.error = \"Account not authorized to trade options\";\n                    errorDetails.suggestion = \"Alpaca sandbox hesabınızın opsiyon işlemleri i\\xe7in yetkilendirilmesi gerekiyor. L\\xfctfen Alpaca Broker Dashboard'dan hesap ayarlarınızı kontrol edin ve opsiyon trading'i aktif edin. Sandbox ortamında opsiyon trading bazı hesaplarda varsayılan olarak kapalı olabilir.\";\n                    errorDetails.code = \"OPTIONS_NOT_AUTHORIZED\";\n                } else if (errorMessageLower.includes(\"buying power\") || errorMessageLower.includes(\"insufficient\") || errorCode === 40310000 && !errorMessageLower.includes(\"authorized\")) {\n                    errorMessage = `Yetersiz alım gücü: ${errorData.message || \"Hesabınızda yeterli bakiye yok\"}`;\n                    errorDetails.error = \"Insufficient buying power\";\n                    errorDetails.buyingPower = errorData.buying_power || \"0\";\n                    errorDetails.costBasis = errorData.cost_basis || \"0\";\n                    errorDetails.suggestion = `Hesabınızda ${errorData.buying_power || \"0\"} USD alım gücü var. İşlem için ${errorData.cost_basis || \"0\"} USD gerekiyor. Lütfen hesabınıza para yükleyin.`;\n                } else if (errorMessageLower.includes(\"insufficient permissions\") || errorMessageLower.includes(\"permission\")) {\n                    errorMessage = \"Alpaca API erişim izni yok. API key'lerinizin gerekli izinlere sahip olduğundan emin olun.\";\n                    errorDetails.error = \"Forbidden - Insufficient permissions\";\n                    errorDetails.suggestion = \"Broker API key'inizde trading izinlerinin aktif olduğundan emin olun. Alpaca Broker Dashboard'dan kontrol edin.\";\n                } else {\n                    errorMessage = `Alpaca API erişim hatası: ${errorData.message || \"İşlem reddedildi\"}`;\n                    errorDetails.error = errorData.error || \"Forbidden\";\n                    errorDetails.suggestion = \"L\\xfctfen hesap ayarlarınızı ve API key izinlerinizi kontrol edin.\";\n                }\n                errorDetails.accountId = accountId || \"Not provided\";\n                errorDetails.body = body ? JSON.stringify(body).substring(0, 200) : \"No body\";\n                errorDetails.apiResponse = errorData; // API'den gelen tam response\n            } else if (response.status === 404) {\n                errorMessage = `Alpaca API endpoint bulunamadı. URL: ${url}, Endpoint: ${endpoint}`;\n                errorDetails.error = \"Endpoint not found\";\n                errorDetails.suggestion = \"Endpoint URL'ini ve account ID'yi kontrol edin.\";\n            } else {\n                errorMessage = errorData.message || errorData.error || `Alpaca API error: ${response.status} - URL: ${url}`;\n                errorDetails.error = errorData.error || errorData.message || \"Unknown error\";\n            }\n            // Detaylı hata bilgilerini logla\n            console.error(\"Alpaca API Error Details:\", JSON.stringify(errorDetails, null, 2));\n            console.error(\"Alpaca API Error Response:\", errorData);\n            // Hata mesajına detayları ekle\n            const detailedMessage = `${errorMessage}\\n\\nDetaylar:\\n${JSON.stringify(errorDetails, null, 2)}`;\n            throw new Error(detailedMessage);\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Alpaca API Error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca hesap bilgilerini getirir (Broker API - account ID ile)\n */ async function getAlpacaAccount(accountId) {\n    // Broker API kullan (v1/accounts/{accountId}) + Trading snapshot (v1/trading/accounts/{accountId})\n    const [accountResult, tradingResult] = await Promise.allSettled([\n        alpacaRequest(`accounts/${accountId}`, \"GET\", undefined, true),\n        alpacaRequest(`trading/accounts/${accountId}/account`, \"GET\", undefined, true)\n    ]);\n    if (accountResult.status !== \"fulfilled\" && tradingResult.status !== \"fulfilled\") {\n        throw accountResult.reason || tradingResult.reason || new Error(\"Alpaca account bilgisi alınamadı\");\n    }\n    const baseAccount = accountResult.status === \"fulfilled\" ? accountResult.value : null;\n    const tradingAccount = tradingResult.status === \"fulfilled\" ? tradingResult.value : null;\n    if (!tradingAccount) {\n        return baseAccount;\n    }\n    const mergedAccount = {\n        ...baseAccount || {},\n        real_time_snapshot: tradingAccount\n    };\n    const realtimeFields = [\n        \"cash\",\n        \"buying_power\",\n        \"equity\",\n        \"portfolio_value\",\n        \"long_market_value\",\n        \"short_market_value\",\n        \"initial_margin\",\n        \"maintenance_margin\",\n        \"last_equity\",\n        \"multiplier\",\n        \"pattern_day_trader\",\n        \"daytrade_count\",\n        \"sma\",\n        \"trade_cash\",\n        \"regt_buying_power\",\n        \"daytrade_buying_power\",\n        \"pending_transfer_in\",\n        \"pending_transfer_out\",\n        \"accrued_fees\"\n    ];\n    realtimeFields.forEach((field)=>{\n        if (tradingAccount[field] !== undefined) {\n            mergedAccount[field] = tradingAccount[field];\n        }\n    });\n    return mergedAccount;\n}\n/**\n * Alpaca pozisyonları getirir (Broker API - account ID ile)\n */ async function getAlpacaPositions(accountId) {\n    // Broker API kullan (v1/trading/accounts/{accountId}/positions)\n    return alpacaRequest(`trading/accounts/${accountId}/positions`, \"GET\", undefined, true);\n}\n/**\n * Alpaca siparişleri getirir\n */ async function getAlpacaOrders(params) {\n    const { accountId, ...queryParams } = params;\n    const queryString = new URLSearchParams();\n    Object.entries(queryParams).forEach(([key, value])=>{\n        if (value !== undefined && key !== \"accountId\") {\n            queryString.append(key, value.toString());\n        }\n    });\n    // Broker API kullan (v1/trading/accounts/{accountId}/orders)\n    const endpoint = `trading/accounts/${accountId}/orders${queryString.toString() ? \"?\" + queryString.toString() : \"\"}`;\n    return alpacaRequest(endpoint, \"GET\", undefined, true);\n}\n/**\n * Alpaca portföy geçmişi getirir\n * Not: Broker API'de portfolio history endpoint'i yok\n * Bu yüzden account bilgilerinden portfolio history oluşturuluyor\n * Account bilgileri equity, portfolio_value, last_equity içerir\n */ async function getAlpacaPortfolioHistory(params) {\n    const { accountId, period = \"1M\" } = params;\n    // Broker API'de portfolio history endpoint'i yok\n    // Bu yüzden account bilgilerinden ve pozisyonlardan portfolio history oluşturuyoruz\n    try {\n        // Account bilgisini al (equity, portfolio_value, last_equity içerir)\n        const account = await getAlpacaAccount(accountId);\n        // Pozisyonları al (kar/zarar hesaplamak için)\n        const positions = await getAlpacaPositions(accountId);\n        const equity = parseFloat(account.equity || \"0\");\n        const lastEquity = parseFloat(account.last_equity || \"0\");\n        const portfolioValue = parseFloat(account.portfolio_value || \"0\");\n        const cash = parseFloat(account.cash || account.trade_cash || \"0\");\n        // Period'a göre gün sayısını hesapla\n        const today = new Date();\n        let daysBack = 30; // Default 1M\n        if (period === \"1d\" || period === \"1D\") daysBack = 1;\n        else if (period === \"1W\") daysBack = 7;\n        else if (period === \"1M\") daysBack = 30;\n        else if (period === \"3M\") daysBack = 90;\n        else if (period === \"6M\") daysBack = 180;\n        else if (period === \"1Y\") daysBack = 365;\n        // Geçmiş verileri oluştur (simüle edilmiş)\n        const history = [];\n        // Başlangıç değeri (last_equity veya equity'den tahmin)\n        const startEquity = lastEquity > 0 ? lastEquity : equity * 0.95; // %5 düşüş varsayımı\n        // Her gün için bir kayıt oluştur\n        for(let i = daysBack; i >= 0; i--){\n            const date = new Date(today);\n            date.setDate(date.getDate() - i);\n            date.setHours(16, 0, 0, 0); // Market close time\n            // Basit bir trend oluştur (gerçek veri yoksa)\n            // Equity'den başlayıp, günlük küçük değişimlerle ilerle\n            const progress = (daysBack - i) / daysBack; // 0'dan 1'e\n            const dailyChange = (equity - startEquity) / daysBack; // Günlük ortalama değişim\n            const variance = (Math.random() - 0.5) * (equity * 0.02); // %2 varyans\n            const estimatedEquity = startEquity + dailyChange * (daysBack - i) + variance;\n            // Pozisyonlardan toplam kar/zarar hesapla (tahmini)\n            const totalPnL = positions.reduce((sum, pos)=>{\n                const unrealizedPL = parseFloat(pos.unrealized_pl || \"0\");\n                return sum + unrealizedPL;\n            }, 0);\n            // Günlük kar/zarar tahmini\n            const dailyPnL = totalPnL / daysBack;\n            const estimatedPnL = dailyPnL * (daysBack - i);\n            history.push({\n                timestamp: date.toISOString(),\n                equity: Math.max(0, estimatedEquity),\n                profit_loss: estimatedPnL,\n                profit_loss_pct: startEquity > 0 ? estimatedPnL / startEquity * 100 : 0\n            });\n        }\n        // Son kayıt gerçek değerlerle güncellenir\n        if (history.length > 0) {\n            const lastRecord = history[history.length - 1];\n            lastRecord.equity = equity;\n            lastRecord.profit_loss = equity - startEquity;\n            lastRecord.profit_loss_pct = startEquity > 0 ? (equity - startEquity) / startEquity * 100 : 0;\n        }\n        const profitLoss = equity - lastEquity;\n        const profitLossPct = lastEquity > 0 ? profitLoss / lastEquity * 100 : 0;\n        return {\n            equity: equity,\n            profit_loss: profitLoss,\n            profit_loss_pct: profitLossPct,\n            history: history\n        };\n    } catch (error) {\n        console.error(\"Portfolio history oluşturma hatası:\", error);\n        // Hata durumunda boş history döndür\n        return {\n            equity: 0,\n            profit_loss: 0,\n            profit_loss_pct: 0,\n            history: []\n        };\n    }\n}\n/**\n * Alpaca'da hisse senedi alım emri verir (Broker API - account ID ile)\n */ async function placeBuyOrder(data) {\n    const { accountId, ...orderData } = data;\n    // Broker API kullan (v1/trading/accounts/{accountId}/orders)\n    return alpacaRequest(`trading/accounts/${accountId}/orders`, \"POST\", orderData, true);\n}\n/**\n * Alpaca'da hisse senedi satım emri verir (Broker API - account ID ile)\n */ async function placeSellOrder(data) {\n    const { accountId, ...orderData } = data;\n    // Broker API kullan (v1/trading/accounts/{accountId}/orders)\n    return alpacaRequest(`trading/accounts/${accountId}/orders`, \"POST\", orderData, true);\n}\n/**\n * Alpaca siparişi iptal eder (Broker API - account ID ile)\n */ async function cancelAlpacaOrder(accountId, orderId) {\n    // Broker API kullan (v1/trading/accounts/{accountId}/orders/{orderId})\n    return alpacaRequest(`trading/accounts/${accountId}/orders/${orderId}`, \"DELETE\", undefined, true);\n}\n/**\n * Alpaca'da opsiyon pozisyonları getirir (Broker API - account ID ile)\n */ async function getAlpacaOptionsPositions(accountId) {\n    try {\n        // Broker API'de options için asset_class parametresi desteklenmiyor\n        // Tüm positions'ı al ve options'ları filtrele\n        const allPositions = await alpacaRequest(`trading/accounts/${accountId}/positions`, \"GET\", undefined, true);\n        // Options pozisyonlarını filtrele\n        // Options genellikle asset_class='option' veya uzun sembol formatında olur\n        const optionsPositions = Array.isArray(allPositions) ? allPositions.filter((pos)=>{\n            // asset_class kontrolü\n            if (pos.asset_class === \"option\") {\n                return true;\n            }\n            // Symbol formatı kontrolü (options genellikle uzun format: AAPL240119C00150000)\n            if (pos.symbol && pos.symbol.length > 10) {\n                // Options sembolleri genellikle tarih ve strike price içerir\n                // Format: SYMBOL + YYMMDD + C/P + STRIKE (örn: AAPL240119C00150000)\n                const optionPattern = /^[A-Z]+\\d{6}[CP]\\d+$/;\n                if (optionPattern.test(pos.symbol)) {\n                    return true;\n                }\n            }\n            return false;\n        }) : [];\n        return optionsPositions;\n    } catch (error) {\n        // Options desteklenmiyorsa veya hata varsa boş array döndür (sessizce handle et)\n        if (error.message?.includes(\"invalid asset_class\") || error.message?.includes(\"404\") || error.message?.includes(\"not found\")) {\n            console.warn(\"Options positions alınamadı, boş array d\\xf6nd\\xfcr\\xfcl\\xfcyor:\", error.message);\n            return [];\n        }\n        // Diğer hatalar için de boş array döndür (options opsiyonel bir özellik)\n        console.warn(\"Options positions hatası (ignored):\", error.message);\n        return [];\n    }\n}\n/**\n * Alpaca'da opsiyon emri verir (Broker API - account ID ile)\n */ async function placeOptionsOrder(data) {\n    const { accountId, ...orderData } = data;\n    // Account ID doğrulama: UUID formatında olmalı (örn: d005ca65-a340-4373-b783-41a0ca3d13f9)\n    // Eğer sayısal bir değerse (account_number), hata ver\n    if (accountId && /^\\d+$/.test(accountId)) {\n        throw new Error(`Geçersiz account ID formatı. UUID formatında bir account ID gereklidir (örn: d005ca65-a340-4373-b783-41a0ca3d13f9). Alınan değer: ${accountId}. Lütfen account ID yerine account UUID kullanın.`);\n    }\n    // Broker API kullan (v1/trading/accounts/{accountId}/orders)\n    return alpacaRequest(`trading/accounts/${accountId}/orders`, \"POST\", orderData, true);\n}\n/**\n * Alpaca'da kripto pozisyonları getirir (Broker API - account ID ile)\n */ async function getAlpacaCryptoPositions(accountId) {\n    // Broker API kullan (v1/trading/accounts/{accountId}/positions?asset_class=crypto)\n    return alpacaRequest(`trading/accounts/${accountId}/positions?asset_class=crypto`, \"GET\", undefined, true);\n}\n/**\n * Alpaca'da kripto emri verir (Broker API - account ID ile)\n */ async function placeCryptoOrder(data) {\n    const { accountId, ...orderData } = data;\n    // Broker API kullan (v1/trading/accounts/{accountId}/orders)\n    return alpacaRequest(`trading/accounts/${accountId}/orders`, \"POST\", orderData, true);\n}\n/**\n * Alpaca'da sembol fiyat bilgisi getirir (Market Data API)\n */ async function getAlpacaQuote(symbol) {\n    // Market Data API için direkt fetch yap\n    const endpoint = `v2/stocks/${symbol}/quotes/latest`;\n    const url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n        \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n    };\n    // Retry mekanizması\n    const fetchWithRetry = async (retries = 3, delay = 500)=>{\n        for(let i = 0; i < retries; i++){\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers\n                });\n                return response;\n            } catch (error) {\n                const isNetworkError = error.code === \"ECONNRESET\" || error.message?.includes(\"fetch failed\") || error.message?.includes(\"ECONNRESET\") || error.message?.includes(\"network\");\n                if (isNetworkError && i < retries - 1) {\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                    delay *= 2;\n                    continue;\n                }\n                throw error;\n            }\n        }\n        throw new Error(\"Max retry limit reached\");\n    };\n    try {\n        const response = await fetchWithRetry();\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            throw new Error(errorData.message || `Market Data API error: ${response.status}`);\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Alpaca Quote API Error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca'da sembol son fiyat bilgisi getirir (Market Data API)\n */ async function getAlpacaLatestTrade(symbol) {\n    // Market Data API için direkt fetch yap\n    const endpoint = `v2/stocks/${symbol}/trades/latest`;\n    const url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n        \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n    };\n    // Retry mekanizması\n    const fetchWithRetry = async (retries = 3, delay = 500)=>{\n        for(let i = 0; i < retries; i++){\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers\n                });\n                return response;\n            } catch (error) {\n                const isNetworkError = error.code === \"ECONNRESET\" || error.message?.includes(\"fetch failed\") || error.message?.includes(\"ECONNRESET\") || error.message?.includes(\"network\");\n                if (isNetworkError && i < retries - 1) {\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                    delay *= 2;\n                    continue;\n                }\n                throw error;\n            }\n        }\n        throw new Error(\"Max retry limit reached\");\n    };\n    try {\n        const response = await fetchWithRetry();\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            throw new Error(errorData.message || `Market Data API error: ${response.status}`);\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Alpaca Latest Trade API Error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca'da kripto için en son trade verisini getirir (Market Data API)\n */ async function getAlpacaCryptoLatestTrade(symbol) {\n    // Market Data API için direkt fetch yap\n    const endpoint = `v1beta3/crypto/${symbol}/trades/latest`;\n    const url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n        \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n    };\n    // Retry mekanizması\n    const fetchWithRetry = async (retries = 3, delay = 500)=>{\n        for(let i = 0; i < retries; i++){\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers\n                });\n                return response;\n            } catch (error) {\n                const isNetworkError = error.code === \"ECONNRESET\" || error.message?.includes(\"fetch failed\") || error.message?.includes(\"ECONNRESET\") || error.message?.includes(\"network\");\n                if (isNetworkError && i < retries - 1) {\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                    delay *= 2;\n                    continue;\n                }\n                throw error;\n            }\n        }\n        throw new Error(\"Max retry limit reached\");\n    };\n    try {\n        const response = await fetchWithRetry();\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            throw new Error(errorData.message || `Crypto Market Data API error: ${response.status}`);\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Alpaca Crypto Latest Trade API Error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca'da opsiyon sembolü için quote verisini getirir (Market Data API - Historical Option Data)\n * Alpaca'nın Historical Option Data API'sini kullanır\n */ async function getAlpacaOptionQuote(optionSymbol) {\n    // Alpaca Historical Option Data API endpoint\n    // v1beta1/options/quotes/latest endpoint'ini kullan\n    const endpoint = `v1beta1/options/quotes/latest?symbols=${optionSymbol}`;\n    const url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n        \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n    };\n    try {\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            // 404 veya 400 (invalid symbol) hataları için null döndür (opsiyon mevcut değil veya geçersiz format)\n            if (response.status === 404 || response.status === 400) {\n                return null;\n            }\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            // Invalid symbol hatası için null döndür\n            if (errorData.message?.includes(\"invalid symbol\") || errorData.code === 400) {\n                return null;\n            }\n            throw new Error(errorData.message || `Option Quote API error: ${response.status}`);\n        }\n        const data = await response.json();\n        // Response format: { quotes: { SYMBOL: {...} } }\n        if (data.quotes && data.quotes[optionSymbol]) {\n            return {\n                quote: data.quotes[optionSymbol]\n            };\n        }\n        return null;\n    } catch (error) {\n        // 404, 400 veya invalid symbol hataları opsiyonun mevcut olmadığı veya geçersiz format olduğu anlamına gelir\n        if (error.message?.includes(\"404\") || error.message?.includes(\"Not Found\") || error.message?.includes(\"invalid symbol\") || error.message?.includes(\"code=400\")) {\n            return null;\n        }\n        console.error(\"Alpaca Option Quote API Error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca'da opsiyon sembolü için trade verisini getirir (Market Data API - Historical Option Data)\n * Alpaca'nın Historical Option Data API'sini kullanır\n */ async function getAlpacaOptionTrade(optionSymbol) {\n    // Alpaca Historical Option Data API endpoint\n    // v1beta1/options/trades/latest endpoint'ini kullan\n    const endpoint = `v1beta1/options/trades/latest?symbols=${optionSymbol}`;\n    const url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n        \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n    };\n    try {\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            // 404 veya 400 (invalid symbol) hataları için null döndür (opsiyon mevcut değil veya geçersiz format)\n            if (response.status === 404 || response.status === 400) {\n                return null;\n            }\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            // Invalid symbol hatası için null döndür\n            if (errorData.message?.includes(\"invalid symbol\") || errorData.code === 400) {\n                return null;\n            }\n            throw new Error(errorData.message || `Option Trade API error: ${response.status}`);\n        }\n        const data = await response.json();\n        // Response format: { trades: { SYMBOL: {...} } }\n        if (data.trades && data.trades[optionSymbol]) {\n            return {\n                trade: data.trades[optionSymbol]\n            };\n        }\n        return null;\n    } catch (error) {\n        // 404, 400 veya invalid symbol hataları opsiyonun mevcut olmadığı veya geçersiz format olduğu anlamına gelir\n        if (error.message?.includes(\"404\") || error.message?.includes(\"Not Found\") || error.message?.includes(\"invalid symbol\") || error.message?.includes(\"code=400\")) {\n            return null;\n        }\n        console.error(\"Alpaca Option Trade API Error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca'da kripto için geçmiş fiyat verilerini (bars) getirir (Market Data API)\n */ async function getAlpacaCryptoBars(symbol, params) {\n    const queryParams = new URLSearchParams();\n    if (params) {\n        Object.entries(params).forEach(([key, value])=>{\n            if (value !== undefined) {\n                queryParams.append(key, value.toString());\n            }\n        });\n    }\n    // Alpaca Market Data API - Crypto\n    // Crypto için endpoint: v1beta3/crypto/bars?symbols={symbol}\n    // symbols parametresi zorunludur ve tek bir sembol olarak gönderilir\n    const timeframe = params?.timeframe || \"1Day\";\n    // Query parametrelerini hazırla - symbols parametresi her zaman ilk sırada olmalı\n    queryParams.set(\"symbols\", symbol); // symbols parametresi zorunlu\n    queryParams.set(\"timeframe\", timeframe);\n    if (params?.start) {\n        queryParams.set(\"start\", params.start);\n    }\n    if (params?.end) {\n        queryParams.set(\"end\", params.end);\n    }\n    if (params?.limit) {\n        queryParams.set(\"limit\", params.limit.toString());\n    }\n    // v1beta3/crypto/bars endpoint'ini kullan\n    const endpoint = `v1beta3/crypto/bars?${queryParams.toString()}`;\n    // Market data için özel URL ve key'ler\n    const url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n        \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n    };\n    try {\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            // Crypto için de subscription hatası olabilir\n            if (errorData.message?.includes(\"subscription\") || errorData.message?.includes(\"SIP\")) {\n                console.warn(\"Crypto subscription hatası:\", errorData.message);\n            }\n            // Detaylı hata mesajı\n            const errorMsg = errorData.message || `Alpaca Market Data API error: ${response.status}`;\n            if (response.status === 404 || errorMsg.includes(\"Not Found\") || errorMsg.includes(\"endpoint not found\")) {\n                throw new Error(`Crypto bars endpoint bulunamadı (${endpoint}). Alpaca crypto market data subscription'ınızın aktif olduğundan ve API key'lerinizin crypto market data erişimine sahip olduğundan emin olun.`);\n            }\n            if (errorMsg.includes(\"symbols\") && errorMsg.includes(\"required\")) {\n                throw new Error(`Crypto bars API hatası: symbols parametresi gerekli. Endpoint: ${endpoint}, Symbol: ${symbol}`);\n            }\n            throw new Error(errorMsg);\n        }\n        const data = await response.json();\n        // v1beta3 endpoint'i { bars: { SYMBOL: [...] } } formatında döner\n        if (data.bars && typeof data.bars === \"object\" && !Array.isArray(data.bars)) {\n            // v1beta3 multi-symbol format: { bars: { SYMBOL: [...] } }\n            const symbolBars = data.bars[symbol] || [];\n            return {\n                bars: symbolBars\n            };\n        } else if (data.bars && Array.isArray(data.bars)) {\n            // Array format: { bars: [...] }\n            return data;\n        } else {\n            // Fallback: direkt bars array'i döndür\n            return {\n                bars: data.bars || []\n            };\n        }\n    } catch (error) {\n        console.error(\"Alpaca Crypto Bars API Error:\", error);\n        console.error(\"Endpoint URL:\", url);\n        console.error(\"Symbol:\", symbol);\n        throw error;\n    }\n}\n/**\n * Alpaca'da sembol için geçmiş fiyat verilerini (bars) getirir (Market Data API - Stocks)\n */ async function getAlpacaBars(symbol, params) {\n    const queryParams = new URLSearchParams();\n    if (params) {\n        Object.entries(params).forEach(([key, value])=>{\n            if (value !== undefined) {\n                queryParams.append(key, value.toString());\n            }\n        });\n    }\n    // Alpaca Market Data API v2 endpoint\n    // IEX feed kullan (ücretsiz, 15 dakika gecikmeli) - SIP subscription gerektirmez\n    const timeframe = params?.timeframe || \"1Day\";\n    queryParams.set(\"timeframe\", timeframe);\n    queryParams.set(\"feed\", \"iex\"); // IEX feed kullan (SIP yerine)\n    const endpoint = `v2/stocks/${symbol}/bars${queryParams.toString() ? \"?\" + queryParams.toString() : \"\"}`;\n    // Market data için özel URL ve key'ler\n    const url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n    const headers = {\n        \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n        \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n    };\n    try {\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    message: response.statusText\n                }));\n            // Daha açıklayıcı hata mesajları\n            if (response.status === 401) {\n                throw new Error(`Market Data API kimlik doğrulama hatası. API key'lerinizi kontrol edin. URL: ${url}, Key: ${ALPACA_MARKET_DATA_API_KEY?.substring(0, 10)}...`);\n            } else if (response.status === 403) {\n                throw new Error(`Market Data API erişim izni yok. API key'lerinizin gerekli izinlere sahip olduğundan emin olun.`);\n            }\n            // Eğer SIP hatası varsa, IEX feed ile tekrar dene\n            if (errorData.message?.includes(\"SIP\") || errorData.message?.includes(\"subscription\")) {\n                // IEX feed zaten eklenmiş, başka bir hata olabilir\n                // Veya daha eski veriler için farklı bir yaklaşım dene\n                console.warn(\"SIP subscription hatası, IEX feed kullanılıyor\");\n            }\n            throw new Error(errorData.message || `Alpaca Market Data API error: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Alpaca Bars API Error:\", error);\n        throw error;\n    }\n}\n/**\n * Broker API'den tüm hesapları getirir\n */ /**\n * Alpaca'dan market clock bilgisini getirir (piyasa açık/kapalı durumu ve saatler)\n */ async function getAlpacaMarketClock() {\n    try {\n        const endpoint = \"v2/clock\";\n        const url = `${ALPACA_BASE_URL}/${endpoint}`;\n        const headers = {\n            \"APCA-API-KEY-ID\": ALPACA_API_KEY,\n            \"APCA-API-SECRET-KEY\": ALPACA_SECRET_KEY\n        };\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Alpaca Market Clock API Error: ${response.status} ${response.statusText} - ${errorText}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Alpaca market clock error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca'dan market calendar bilgisini getirir (piyasa takvimi)\n */ async function getAlpacaMarketCalendar(params) {\n    try {\n        const queryParams = new URLSearchParams();\n        if (params?.start) {\n            queryParams.append(\"start\", params.start);\n        }\n        if (params?.end) {\n            queryParams.append(\"end\", params.end);\n        }\n        // Market Calendar Data API'de olabilir, önce Data API'yi dene\n        const endpoint = `v1/calendar${queryParams.toString() ? \"?\" + queryParams.toString() : \"\"}`;\n        // Önce Data API'yi dene\n        let url = `${ALPACA_MARKET_DATA_URL}/${endpoint}`;\n        let headers = {\n            \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n            \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n        };\n        let response = await fetch(url, {\n            method: \"GET\",\n            headers\n        });\n        // Eğer Data API'de yoksa, Trading API'yi dene\n        if (!response.ok && response.status === 404) {\n            url = `${ALPACA_BASE_URL}/${endpoint}`;\n            headers = {\n                \"APCA-API-KEY-ID\": ALPACA_API_KEY,\n                \"APCA-API-SECRET-KEY\": ALPACA_SECRET_KEY\n            };\n            response = await fetch(url, {\n                method: \"GET\",\n                headers\n            });\n        }\n        if (!response.ok) {\n            // 404 hatası durumunda sessizce null döndür (fallback kullanılacak)\n            if (response.status === 404) {\n                return null;\n            }\n            const errorText = await response.text();\n            throw new Error(`Alpaca Market Calendar API Error: ${response.status} ${response.statusText} - ${errorText}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        // 404 hatası durumunda sessizce null döndür (fallback kullanılacak)\n        if (error.message && error.message.includes(\"404\")) {\n            return null;\n        }\n        // Diğer hatalar için sadece debug modunda logla\n        if (true) {\n            console.warn(\"Alpaca market calendar error (fallback will be used):\", error.message);\n        }\n        return null;\n    }\n}\nasync function getAlpacaAccounts() {\n    // Broker API kullan (v1/accounts)\n    return alpacaRequest(\"accounts\", \"GET\", undefined, true);\n}\n/**\n * Alpaca'da tüm aktif varlıkları (assets) getirir\n * Not: Assets endpoint'i Trading API'de olabilir, ancak Market Data API key'leri ile çalışmayabilir\n * Bu yüzden önce Trading API'yi dene, hata olursa Market Data API'yi dene\n */ async function getAlpacaAssets(params) {\n    const queryParams = new URLSearchParams();\n    if (params) {\n        Object.entries(params).forEach(([key, value])=>{\n            if (value !== undefined) {\n                queryParams.append(key, value.toString());\n            }\n        });\n    }\n    // Endpoint'te v2/ olmamalı, alpacaRequest zaten v2/ ekliyor\n    const endpoint = `assets${queryParams.toString() ? \"?\" + queryParams.toString() : \"\"}`;\n    // Önce Trading API'yi dene\n    try {\n        return await alpacaRequest(endpoint, \"GET\", undefined, false);\n    } catch (error) {\n        // Trading API başarısız olursa, Market Data API'yi dene\n        console.warn(\"Trading API assets endpoint failed, trying Market Data API:\", error.message);\n        // Market Data API için direkt fetch yap\n        // Market Data API'de endpoint'e v2/ eklenmeli\n        const marketDataEndpoint = `v2/${endpoint}`;\n        const url = `${ALPACA_MARKET_DATA_URL}/${marketDataEndpoint}`;\n        const headers = {\n            \"APCA-API-KEY-ID\": ALPACA_MARKET_DATA_API_KEY,\n            \"APCA-API-SECRET-KEY\": ALPACA_MARKET_DATA_SECRET_KEY\n        };\n        try {\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers\n            });\n            if (!response.ok) {\n                throw new Error(`Market Data API error: ${response.status}`);\n            }\n            return await response.json();\n        } catch (marketDataError) {\n            // Her iki API de başarısız olursa hatayı fırlat\n            console.error(\"Both Trading API and Market Data API failed for assets:\", marketDataError);\n            throw new Error(`Assets endpoint mevcut değil veya API key'ler yanlış yapılandırılmış. Trading API: ${error.message}, Market Data API: ${marketDataError.message}`);\n        }\n    }\n}\n/**\n * Alpaca'da hesabı kapatır (CLOSED durumuna alır)\n */ async function closeAlpacaAccount(accountId) {\n    try {\n        const closePayload = {\n            status: \"CLOSED\",\n            reason: \"Hesap kullanıcı talebi \\xfczerine kapatıldı\"\n        };\n        // Broker API kullanarak hesabı kapat\n        return alpacaRequest(`trading/accounts/${accountId}`, \"PATCH\", closePayload, true, accountId);\n    } catch (error) {\n        console.error(\"Alpaca close account error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca'da yeni trading hesabı oluşturur (Broker API)\n */ async function createAlpacaAccount(data) {\n    const accountPayload = {\n        contact: data.contact,\n        identity: data.identity,\n        ...data.disclosures && {\n            disclosures: data.disclosures\n        },\n        ...data.agreements && {\n            agreements: data.agreements\n        },\n        ...data.trusted_contact && {\n            trusted_contact: data.trusted_contact\n        },\n        ...data.enabled_assets && {\n            enabled_assets: data.enabled_assets\n        }\n    };\n    // Broker API kullan (v1/accounts)\n    return alpacaRequest(\"accounts\", \"POST\", accountPayload, true);\n}\n/**\n * Alpaca hesabına para yatırır (funding/deposit)\n * Not: Sandbox ortamında bu işlem sınırlı olabilir\n */ async function depositToAlpacaAccount(data) {\n    try {\n        // Alpaca Broker API'de funding endpoint'i\n        // Not: Sandbox'ta bu endpoint sınırlı olabilir, gerçek ortamda kullanılmalı\n        const fundingPayload = {\n            amount: data.amount.toString(),\n            currency: data.currency || \"USD\",\n            notes: data.notes || `Deposit from Mambu account`\n        };\n        // Broker API kullan (v1/accounts/{accountId}/funding veya benzeri)\n        // Not: Alpaca'nın gerçek funding endpoint'i dokümantasyondan kontrol edilmeli\n        // Şimdilik accounts/{accountId} endpoint'ine POST yapıyoruz\n        return alpacaRequest(`accounts/${data.accountId}/funding`, \"POST\", fundingPayload, true);\n    } catch (error) {\n        console.error(\"Alpaca deposit error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca hesabından para çeker (withdrawal)\n * Not: Sandbox ortamında bu işlem sınırlı olabilir\n */ async function withdrawFromAlpacaAccount(data) {\n    try {\n        // Alpaca Broker API'de withdrawal endpoint'i\n        // Not: Sandbox'ta bu endpoint sınırlı olabilir, gerçek ortamda kullanılmalı\n        const withdrawalPayload = {\n            amount: data.amount.toString(),\n            currency: data.currency || \"USD\",\n            notes: data.notes || `Withdrawal to Mambu account`\n        };\n        // Broker API kullan (v1/accounts/{accountId}/withdrawal veya benzeri)\n        // Not: Alpaca'nın gerçek withdrawal endpoint'i dokümantasyondan kontrol edilmeli\n        return alpacaRequest(`accounts/${data.accountId}/withdrawal`, \"POST\", withdrawalPayload, true);\n    } catch (error) {\n        console.error(\"Alpaca withdrawal error:\", error);\n        throw error;\n    }\n}\n/**\n * Email ile Alpaca hesabı bulur\n */ async function findAlpacaAccountByEmail(email) {\n    try {\n        const accounts = await getAlpacaAccounts();\n        if (!Array.isArray(accounts)) {\n            return null;\n        }\n        const account = accounts.find((acc)=>acc.contact?.email_address === email || acc.email === email || acc.email_address === email);\n        return account || null;\n    } catch (error) {\n        console.error(\"Find Alpaca account by email error:\", error);\n        return null;\n    }\n}\n/**\n * Alpaca'da hesap izinlerini günceller (opsiyon ve kripto)\n */ async function updateAlpacaAccountPermissions(accountId, permissions) {\n    try {\n        // Alpaca'da izin güncelleme için PATCH endpoint'i kullanılır\n        // enabled_assets array'i ile kontrol edilir\n        const currentAccount = await getAlpacaAccount(accountId);\n        const currentAssets = currentAccount?.enabled_assets || [];\n        const updatedAssets = [\n            ...currentAssets\n        ];\n        // Opsiyon izni\n        if (permissions.options_enabled !== undefined) {\n            if (permissions.options_enabled && !updatedAssets.includes(\"us_option\")) {\n                updatedAssets.push(\"us_option\");\n            } else if (!permissions.options_enabled && updatedAssets.includes(\"us_option\")) {\n                updatedAssets.splice(updatedAssets.indexOf(\"us_option\"), 1);\n            }\n        }\n        // Kripto izni\n        if (permissions.crypto_enabled !== undefined) {\n            if (permissions.crypto_enabled && !updatedAssets.includes(\"crypto\")) {\n                updatedAssets.push(\"crypto\");\n            } else if (!permissions.crypto_enabled && updatedAssets.includes(\"crypto\")) {\n                updatedAssets.splice(updatedAssets.indexOf(\"crypto\"), 1);\n            }\n        }\n        const updatePayload = {\n            enabled_assets: updatedAssets\n        };\n        // Broker API kullan (v1/accounts/{accountId})\n        return alpacaRequest(`accounts/${accountId}`, \"PATCH\", updatePayload, true);\n    } catch (error) {\n        console.error(\"Update Alpaca account permissions error:\", error);\n        throw error;\n    }\n}\n/**\n * Alpaca API yapılandırmasını kontrol eder\n */ function isAlpacaConfigured() {\n    return !!(ALPACA_API_KEY && ALPACA_SECRET_KEY);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWdCa0I7UUFDbEI7UUFFQSw4Q0FBOEM7UUFDOUMsT0FBT3pNLGNBQWMsQ0FBQyxTQUFTLEVBQUVLLFVBQVUsQ0FBQyxFQUFFLFNBQVN5TSxlQUFlO0lBQ3hFLEVBQUUsT0FBT3ZMLE9BQVk7UUFDbkJLLFFBQVFMLEtBQUssQ0FBQyw0Q0FBNENBO1FBQzFELE1BQU1BO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU3dMO0lBQ2QsT0FBTyxDQUFDLENBQUUvTixDQUFBQSxrQkFBa0JHLGlCQUFnQjtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdHBheS8uL2xpYi9hbHBhY2EudHM/NzEzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFscGFjYSBNYXJrZXRzIEFQSSBDbGllbnRcbiAqIEFscGFjYSBBUEkgaWxlIGlsZXRpxZ9pbSBpw6dpbiB5YXJkxLFtY8SxIGZvbmtzaXlvbmxhclxuICovXG5cbi8vIFRyYWRpbmcgQVBJIGnDp2luIGtleSdsZXIgKGFsxLFtLXNhdMSxbSwgcG9ydGbDtnksIHBvemlzeW9uLCBhY2NvdW50IGRhdGEpXG5jb25zdCBBTFBBQ0FfQVBJX0tFWSA9IHByb2Nlc3MuZW52LkFMUEFDQV9BUElfS0VZIHx8ICcnO1xuY29uc3QgQUxQQUNBX1NFQ1JFVF9LRVkgPSBwcm9jZXNzLmVudi5BTFBBQ0FfU0VDUkVUX0tFWSB8fCAnJztcbmNvbnN0IEFMUEFDQV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52LkFMUEFDQV9CQVNFX1VSTCB8fCAnaHR0cHM6Ly9wYXBlci1hcGkuYWxwYWNhLm1hcmtldHMnOyAvLyBQYXBlciB0cmFkaW5nIGRlZmF1bHRcblxuLy8gQnJva2VyIEFQSSBpw6dpbiBheXLEsSBrZXknbGVyIChtw7zFn3Rlcmkgb2x1xZ90dXJtYSwgS1lDLCBoZXNhcCBhw6dtYSlcbmNvbnN0IEFMUEFDQV9CUk9LRVJfQVBJX1VSTCA9IHByb2Nlc3MuZW52LkFMUEFDQV9CUk9LRVJfQVBJX1VSTCB8fCAnaHR0cHM6Ly9icm9rZXItYXBpLnNhbmRib3guYWxwYWNhLm1hcmtldHMnO1xuY29uc3QgQUxQQUNBX0JST0tFUl9BUElfS0VZID0gcHJvY2Vzcy5lbnYuQUxQQUNBX0JST0tFUl9BUElfS0VZIHx8IHByb2Nlc3MuZW52LkFMUEFDQV9BUElfS0VZIHx8ICcnO1xuY29uc3QgQUxQQUNBX0JST0tFUl9TRUNSRVRfS0VZID0gcHJvY2Vzcy5lbnYuQUxQQUNBX0JST0tFUl9TRUNSRVRfS0VZIHx8IHByb2Nlc3MuZW52LkFMUEFDQV9TRUNSRVRfS0VZIHx8ICcnO1xuXG4vLyBNYXJrZXQgRGF0YSBBUEkgacOnaW4gYXlyxLEga2V5J2xlciB2ZSBVUkxcbi8vIE5vdDogVHJhZGluZyBBUEkga2V5J2xlcmkgTWFya2V0IERhdGEgQVBJIGnDp2luIGRlIGt1bGxhbsSxbGFiaWxpclxuLy8gTWFya2V0IERhdGEgQVBJIFVSTCdpIGhlciB6YW1hbiBodHRwczovL2RhdGEuYWxwYWNhLm1hcmtldHMgb2xtYWzEsVxuY29uc3QgQUxQQUNBX01BUktFVF9EQVRBX1VSTCA9IHByb2Nlc3MuZW52LkFMUEFDQV9NQVJLRVRfREFUQV9VUkwgfHwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQUxQQUNBX0RBVEFfQVBJX1VSTCB8fCAnaHR0cHM6Ly9kYXRhLmFscGFjYS5tYXJrZXRzJztcbi8vIEtleSdsZXIgacOnaW4gZmFsbGJhY2s6IMOWbmNlIE1hcmtldCBEYXRhIEFQSSBrZXknbGVyaSwgeW9rc2EgVHJhZGluZyBBUEkga2V5J2xlcmlcbmNvbnN0IEFMUEFDQV9NQVJLRVRfREFUQV9BUElfS0VZID0gcHJvY2Vzcy5lbnYuQUxQQUNBX01BUktFVF9BUElfS0VZIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FMUEFDQV9NQVJLRVRfQVBJX0tFWSB8fCBwcm9jZXNzLmVudi5BTFBBQ0FfQVBJX0tFWSB8fCAnJztcbmNvbnN0IEFMUEFDQV9NQVJLRVRfREFUQV9TRUNSRVRfS0VZID0gcHJvY2Vzcy5lbnYuQUxQQUNBX01BUktFVF9TRUNSRVRfS0VZIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FMUEFDQV9NQVJLRVRfU0VDUkVUX0tFWSB8fCBwcm9jZXNzLmVudi5BTFBBQ0FfU0VDUkVUX0tFWSB8fCAnJztcblxuaW50ZXJmYWNlIEFscGFjYUFjY291bnQge1xuICBpZD86IHN0cmluZzsgLy8gVVVJRCBmb3JtYXTEsW5kYSBhY2NvdW50IElEIChCcm9rZXIgQVBJIGnDp2luKVxuICBhY2NvdW50X251bWJlcjogc3RyaW5nOyAvLyBTYXnEsXNhbCBhY2NvdW50IG51bWJlclxuICBzdGF0dXM6IHN0cmluZztcbiAgY3VycmVuY3k6IHN0cmluZztcbiAgYnV5aW5nX3Bvd2VyOiBzdHJpbmc7XG4gIGNhc2g6IHN0cmluZztcbiAgcG9ydGZvbGlvX3ZhbHVlOiBzdHJpbmc7XG4gIHBhdHRlcm5fZGF5X3RyYWRlcjogYm9vbGVhbjtcbiAgdHJhZGluZ19ibG9ja2VkOiBib29sZWFuO1xuICB0cmFuc2ZlcnNfYmxvY2tlZDogYm9vbGVhbjtcbiAgYWNjb3VudF9ibG9ja2VkOiBib29sZWFuO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHRyYWRlX3N1c3BlbmRlZF9ieV91c2VyOiBib29sZWFuO1xuICBtdWx0aXBsaWVyOiBzdHJpbmc7XG4gIHNob3J0aW5nX2VuYWJsZWQ6IGJvb2xlYW47XG4gIGVxdWl0eTogc3RyaW5nO1xuICBsYXN0X2VxdWl0eTogc3RyaW5nO1xuICBsb25nX21hcmtldF92YWx1ZTogc3RyaW5nO1xuICBzaG9ydF9tYXJrZXRfdmFsdWU6IHN0cmluZztcbiAgaW5pdGlhbF9tYXJnaW46IHN0cmluZztcbiAgbWFpbnRlbmFuY2VfbWFyZ2luOiBzdHJpbmc7XG4gIHNtYTogc3RyaW5nO1xuICBkYXl0cmFkZV9jb3VudDogbnVtYmVyO1xuICB0cmFkZV9jYXNoPzogc3RyaW5nO1xuICByZWd0X2J1eWluZ19wb3dlcj86IHN0cmluZztcbiAgZGF5dHJhZGVfYnV5aW5nX3Bvd2VyPzogc3RyaW5nO1xuICBwZW5kaW5nX3RyYW5zZmVyX2luPzogc3RyaW5nO1xuICBwZW5kaW5nX3RyYW5zZmVyX291dD86IHN0cmluZztcbiAgcmVhbF90aW1lX3NuYXBzaG90PzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuaW50ZXJmYWNlIEFscGFjYVBvc2l0aW9uIHtcbiAgYXNzZXRfaWQ6IHN0cmluZztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIGV4Y2hhbmdlOiBzdHJpbmc7XG4gIGFzc2V0X2NsYXNzOiBzdHJpbmc7XG4gIHF0eTogc3RyaW5nO1xuICBzaWRlOiBzdHJpbmc7XG4gIG1hcmtldF92YWx1ZTogc3RyaW5nO1xuICBjb3N0X2Jhc2lzOiBzdHJpbmc7XG4gIHVucmVhbGl6ZWRfcGw6IHN0cmluZztcbiAgdW5yZWFsaXplZF9wbHBjOiBzdHJpbmc7XG4gIHVucmVhbGl6ZWRfaW50cmFkYXlfcGw6IHN0cmluZztcbiAgdW5yZWFsaXplZF9pbnRyYWRheV9wbHBjOiBzdHJpbmc7XG4gIGN1cnJlbnRfcHJpY2U6IHN0cmluZztcbiAgbGFzdGRheV9wcmljZTogc3RyaW5nO1xuICBjaGFuZ2VfdG9kYXk6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEFscGFjYU9yZGVyIHtcbiAgaWQ6IHN0cmluZztcbiAgY2xpZW50X29yZGVyX2lkOiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xuICBzdWJtaXR0ZWRfYXQ6IHN0cmluZztcbiAgZmlsbGVkX2F0OiBzdHJpbmcgfCBudWxsO1xuICBleHBpcmVkX2F0OiBzdHJpbmcgfCBudWxsO1xuICBjYW5jZWxlZF9hdDogc3RyaW5nIHwgbnVsbDtcbiAgZmFpbGVkX2F0OiBzdHJpbmcgfCBudWxsO1xuICByZXBsYWNlZF9hdDogc3RyaW5nIHwgbnVsbDtcbiAgcmVwbGFjZWRfYnk6IHN0cmluZyB8IG51bGw7XG4gIHJlcGxhY2VzOiBzdHJpbmcgfCBudWxsO1xuICBhc3NldF9pZDogc3RyaW5nO1xuICBzeW1ib2w6IHN0cmluZztcbiAgYXNzZXRfY2xhc3M6IHN0cmluZztcbiAgbm90aW9uYWw6IHN0cmluZyB8IG51bGw7XG4gIHF0eTogc3RyaW5nIHwgbnVsbDtcbiAgZmlsbGVkX3F0eTogc3RyaW5nO1xuICBmaWxsZWRfYXZnX3ByaWNlOiBzdHJpbmcgfCBudWxsO1xuICBvcmRlcl9jbGFzczogc3RyaW5nO1xuICBvcmRlcl90eXBlOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgc2lkZTogc3RyaW5nO1xuICB0aW1lX2luX2ZvcmNlOiBzdHJpbmc7XG4gIGxpbWl0X3ByaWNlOiBzdHJpbmcgfCBudWxsO1xuICBzdG9wX3ByaWNlOiBzdHJpbmcgfCBudWxsO1xuICBzdGF0dXM6IHN0cmluZztcbiAgZXh0ZW5kZWRfaG91cnM6IGJvb2xlYW47XG4gIGxlZ3M6IGFueVtdIHwgbnVsbDtcbiAgdHJhaWxfcGVyY2VudDogc3RyaW5nIHwgbnVsbDtcbiAgdHJhaWxfcHJpY2U6IHN0cmluZyB8IG51bGw7XG4gIGh3bTogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBBbHBhY2EgQVBJJ3llIGlzdGVrIGfDtm5kZXJpclxuICovXG5hc3luYyBmdW5jdGlvbiBhbHBhY2FSZXF1ZXN0KFxuICBlbmRwb2ludDogc3RyaW5nLFxuICBtZXRob2Q6ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJyA9ICdHRVQnLFxuICBib2R5PzogYW55LFxuICB1c2VCcm9rZXJBUEk6IGJvb2xlYW4gPSBmYWxzZSxcbiAgYWNjb3VudElkPzogc3RyaW5nIC8vIE9wc2l5b25lbDogQmVsaXJsaSBiaXIgYWNjb3VudCBJRCBpw6dpblxuKTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gVHJhZGluZyBBUEkgacOnaW4gdjIsIEJyb2tlciBBUEkgacOnaW4gdjEga3VsbGFuXG4gIGNvbnN0IGJhc2VVcmwgPSB1c2VCcm9rZXJBUEkgPyBBTFBBQ0FfQlJPS0VSX0FQSV9VUkwgOiBBTFBBQ0FfQkFTRV9VUkw7XG4gIGNvbnN0IGFwaUtleSA9IHVzZUJyb2tlckFQSSA/IEFMUEFDQV9CUk9LRVJfQVBJX0tFWSA6IEFMUEFDQV9BUElfS0VZO1xuICBjb25zdCBzZWNyZXRLZXkgPSB1c2VCcm9rZXJBUEkgPyBBTFBBQ0FfQlJPS0VSX1NFQ1JFVF9LRVkgOiBBTFBBQ0FfU0VDUkVUX0tFWTtcbiAgY29uc3QgdmVyc2lvbiA9IHVzZUJyb2tlckFQSSA/ICd2MScgOiAndjInO1xuICBcbiAgLy8gRcSfZXIgYWNjb3VudCBJRCB2ZXJpbG1pxZ9zZSB2ZSBicm9rZXIgQVBJIGt1bGxhbsSxbMSxeW9yc2EsIGVuZHBvaW50J2UgZWtsZVxuICBsZXQgZmluYWxFbmRwb2ludCA9IGVuZHBvaW50O1xuICBpZiAodXNlQnJva2VyQVBJKSB7XG4gICAgLy8gQnJva2VyIEFQSSBpw6dpbiBlbmRwb2ludCB5YXDEsXPEsTogdHJhZGluZy9hY2NvdW50cy97YWNjb3VudElkfS8uLi5cbiAgICAvLyBFxJ9lciBlbmRwb2ludCB6YXRlbiB0cmFkaW5nL2FjY291bnRzLyBpbGUgYmHFn2zEsXlvcnNhLCBhY2NvdW50SWQgemF0ZW4gacOnaW5kZSB2YXIgZGVtZWt0aXJcbiAgICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aCgndHJhZGluZy9hY2NvdW50cy8nKSkge1xuICAgICAgLy8gWmF0ZW4gdHJhZGluZy9hY2NvdW50cy97YWNjb3VudElkfS8gZm9ybWF0xLFuZGEsIGRlxJ9pxZ90aXJtZVxuICAgICAgZmluYWxFbmRwb2ludCA9IGVuZHBvaW50O1xuICAgIH0gZWxzZSBpZiAoYWNjb3VudElkKSB7XG4gICAgICAvLyB0cmFkaW5nL2FjY291bnRzL3thY2NvdW50SWR9LyBwcmVmaXgnaSBla2xlXG4gICAgICBmaW5hbEVuZHBvaW50ID0gYHRyYWRpbmcvYWNjb3VudHMvJHthY2NvdW50SWR9LyR7ZW5kcG9pbnR9YDtcbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9LyR7dmVyc2lvbn0vJHtmaW5hbEVuZHBvaW50fWA7XG4gIFxuICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICdBUENBLUFQSS1LRVktSUQnOiBhcGlLZXksXG4gICAgJ0FQQ0EtQVBJLVNFQ1JFVC1LRVknOiBzZWNyZXRLZXksXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfTtcblxuICAvLyBSZXRyeSBtZWthbml6bWFzxLEgaWxlIGZldGNoXG4gIGNvbnN0IGZldGNoV2l0aFJldHJ5ID0gYXN5bmMgKHJldHJpZXMgPSAzLCBkZWxheSA9IDEwMDApOiBQcm9taXNlPFJlc3BvbnNlPiA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyaWVzOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keTogYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAvLyBOZXR3b3JrIGhhdGFsYXLEsSBpw6dpbiByZXRyeSB5YXAgKEVDT05OUkVTRVQsIGZldGNoIGZhaWxlZCwgdmIuKVxuICAgICAgICBjb25zdCBpc05ldHdvcmtFcnJvciA9IGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJyB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdmZXRjaCBmYWlsZWQnKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdFQ09OTlJFU0VUJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCduZXR3b3JrJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCd0aW1lb3V0Jyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaXNOZXR3b3JrRXJyb3IgJiYgaSA8IHJldHJpZXMgLSAxKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBBbHBhY2EgQVBJIG5ldHdvcmsgaGF0YXPEsSAoZGVuZW1lICR7aSArIDF9LyR7cmV0cmllc30pLCAke2RlbGF5fW1zIHNvbnJhIHRla3JhciBkZW5lbml5b3IuLi5gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgICBkZWxheSAqPSAyOyAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWF4IHJldHJ5IGxpbWl0IHJlYWNoZWQnKTtcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkoKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IH0pKTtcbiAgICAgIFxuICAgICAgLy8gRGFoYSBhw6fEsWtsYXnEsWPEsSBoYXRhIG1lc2FqbGFyxLEgdmUgZGV0YXlsxLEgbG9nbGFtYVxuICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgbGV0IGVycm9yRGV0YWlsczogYW55ID0ge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGVuZHBvaW50OiBlbmRwb2ludCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGFwaVR5cGU6IHVzZUJyb2tlckFQSSA/ICdCcm9rZXIgQVBJJyA6ICdUcmFkaW5nIEFQSScsXG4gICAgICAgIGFwaUtleVByZWZpeDogYXBpS2V5ID8gYCR7YXBpS2V5LnN1YnN0cmluZygwLCA4KX0uLi5gIDogJ01JU1NJTkcnLFxuICAgICAgfTtcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdBbHBhY2EgQVBJIGtpbWxpayBkb8SfcnVsYW1hIGhhdGFzxLEuIEzDvHRmZW4gQVBJIGtleVxcJ2xlcmluaXppIGtvbnRyb2wgZWRpbi4nO1xuICAgICAgICBlcnJvckRldGFpbHMuZXJyb3IgPSAnQXV0aGVudGljYXRpb24gZmFpbGVkJztcbiAgICAgICAgZXJyb3JEZXRhaWxzLnN1Z2dlc3Rpb24gPSAnQVBJIGtleSB2ZSBzZWNyZXQga2V5XFwnbGVyaW4gZG/En3J1IG9sZHXEn3VuZGFuIGVtaW4gb2x1bi4nO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAvLyA0MDMgaGF0YXPEsSBpw6dpbiDDtnplbCBrb250cm9sOiBQRFQgPiBvcHRpb25zIGF1dGhvcml6YXRpb24gPiBidXlpbmcgcG93ZXIgPiBwZXJtaXNzaW9uc1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VMb3dlciA9IGVycm9yRGF0YS5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpIHx8ICcnO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBlcnJvckRhdGEuY29kZTtcbiAgICAgICAgXG4gICAgICAgIC8vIDEuIMOWbmNlIFBEVCAoUGF0dGVybiBEYXkgVHJhZGluZykga29udHJvbMO8IC0gZW4gw7ZuY2VsaWtsaVxuICAgICAgICBpZiAoZXJyb3JDb2RlID09PSA0MDMxMDEwMCB8fCBlcnJvck1lc3NhZ2VMb3dlci5pbmNsdWRlcygncGF0dGVybiBkYXkgdHJhZGluZycpIHx8IGVycm9yTWVzc2FnZUxvd2VyLmluY2x1ZGVzKCdwZHQnKSB8fCBlcnJvck1lc3NhZ2VMb3dlci5pbmNsdWRlcygndHJhZGUgZGVuaWVkIGR1ZSB0byBwYXR0ZXJuIGRheSB0cmFkaW5nJykpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnUGF0dGVybiBEYXkgVHJhZGluZyAoUERUKSBLb3J1bWFzxLE6IMSwxZ9sZW0gcmVkZGVkaWxkaS4nO1xuICAgICAgICAgIGVycm9yRGV0YWlscy5lcnJvciA9ICdQYXR0ZXJuIERheSBUcmFkaW5nIFByb3RlY3Rpb24nO1xuICAgICAgICAgIGVycm9yRGV0YWlscy5zdWdnZXN0aW9uID0gJ0hlc2FixLFuxLF6ZGEgJDI1LDAwMFxcJ2RlbiBheiBiYWtpeWUgdmFyc2EgdmUgNSBpxZ8gZ8O8bsO8IGnDp2luZGUgNCB2ZXlhIGRhaGEgZmF6bGEgZ8O8bi10cmFkZSB5YXB0xLF5c2FuxLF6LCBoZXNhYsSxbsSxeiA5MCBnw7xuIGJveXVuY2Ega8Sxc8SxdGxhbsSxci4gSGVzYWLEsW7EsXphICQyNSwwMDAgdmV5YSBkYWhhIGZhemxhIHBhcmEgeWF0xLFyYXJhayBidSBrxLFzxLF0bGFtYXnEsSBrYWxkxLFyYWJpbGlyc2luaXouJztcbiAgICAgICAgICBlcnJvckRldGFpbHMucGR0SW5mbyA9IHtcbiAgICAgICAgICAgIHJlYXNvbjogJ1BhdHRlcm4gRGF5IFRyYWRpbmcga29ydW1hc8SxIGFrdGlmJyxcbiAgICAgICAgICAgIHNvbHV0aW9uOiAnSGVzYWLEsW7EsXphICQyNSwwMDAgdmV5YSBkYWhhIGZhemxhIHBhcmEgeWF0xLFyxLFuJyxcbiAgICAgICAgICAgIHJlc3RyaWN0aW9uOiAnOTAgZ8O8biBib3l1bmNhIGfDvG4tdHJhZGUgeWFwYW1henPEsW7EsXonLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gT3BzaXlvbiB5ZXRraWxlbmRpcm1lIGtvbnRyb2zDvFxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICBlcnJvck1lc3NhZ2VMb3dlci5pbmNsdWRlcygnbm90IGF1dGhvcml6ZWQgdG8gdHJhZGUgb3B0aW9ucycpIHx8XG4gICAgICAgICAgZXJyb3JNZXNzYWdlTG93ZXIuaW5jbHVkZXMoJ2FjY291bnQgbm90IGF1dGhvcml6ZWQgdG8gdHJhZGUgb3B0aW9ucycpIHx8XG4gICAgICAgICAgKGVycm9yQ29kZSA9PT0gNDAzMTAwMDAgJiYgZXJyb3JNZXNzYWdlTG93ZXIuaW5jbHVkZXMoJ29wdGlvbnMnKSkgfHxcbiAgICAgICAgICAoZXJyb3JDb2RlID09PSA0MDMxMDAwMCAmJiBlcnJvck1lc3NhZ2VMb3dlci5pbmNsdWRlcygnYXV0aG9yaXplZCcpKVxuICAgICAgICApIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnSGVzYWLEsW7EsXogb3BzaXlvbiBpxZ9sZW1sZXJpIGnDp2luIHlldGtpbGVuZGlyaWxtZW1pxZ8uJztcbiAgICAgICAgICBlcnJvckRldGFpbHMuZXJyb3IgPSAnQWNjb3VudCBub3QgYXV0aG9yaXplZCB0byB0cmFkZSBvcHRpb25zJztcbiAgICAgICAgICBlcnJvckRldGFpbHMuc3VnZ2VzdGlvbiA9ICdBbHBhY2Egc2FuZGJveCBoZXNhYsSxbsSxesSxbiBvcHNpeW9uIGnFn2xlbWxlcmkgacOnaW4geWV0a2lsZW5kaXJpbG1lc2kgZ2VyZWtpeW9yLiBMw7x0ZmVuIEFscGFjYSBCcm9rZXIgRGFzaGJvYXJkXFwnZGFuIGhlc2FwIGF5YXJsYXLEsW7EsXrEsSBrb250cm9sIGVkaW4gdmUgb3BzaXlvbiB0cmFkaW5nXFwnaSBha3RpZiBlZGluLiBTYW5kYm94IG9ydGFtxLFuZGEgb3BzaXlvbiB0cmFkaW5nIGJhesSxIGhlc2FwbGFyZGEgdmFyc2F5xLFsYW4gb2xhcmFrIGthcGFsxLEgb2xhYmlsaXIuJztcbiAgICAgICAgICBlcnJvckRldGFpbHMuY29kZSA9ICdPUFRJT05TX05PVF9BVVRIT1JJWkVEJztcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBCdXlpbmcgcG93ZXIga29udHJvbMO8XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIGVycm9yTWVzc2FnZUxvd2VyLmluY2x1ZGVzKCdidXlpbmcgcG93ZXInKSB8fFxuICAgICAgICAgIGVycm9yTWVzc2FnZUxvd2VyLmluY2x1ZGVzKCdpbnN1ZmZpY2llbnQnKSB8fFxuICAgICAgICAgIChlcnJvckNvZGUgPT09IDQwMzEwMDAwICYmICFlcnJvck1lc3NhZ2VMb3dlci5pbmNsdWRlcygnYXV0aG9yaXplZCcpKVxuICAgICAgICApIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgWWV0ZXJzaXogYWzEsW0gZ8O8Y8O8OiAke2Vycm9yRGF0YS5tZXNzYWdlIHx8ICdIZXNhYsSxbsSxemRhIHlldGVybGkgYmFraXllIHlvayd9YDtcbiAgICAgICAgICBlcnJvckRldGFpbHMuZXJyb3IgPSAnSW5zdWZmaWNpZW50IGJ1eWluZyBwb3dlcic7XG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmJ1eWluZ1Bvd2VyID0gZXJyb3JEYXRhLmJ1eWluZ19wb3dlciB8fCAnMCc7XG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmNvc3RCYXNpcyA9IGVycm9yRGF0YS5jb3N0X2Jhc2lzIHx8ICcwJztcbiAgICAgICAgICBlcnJvckRldGFpbHMuc3VnZ2VzdGlvbiA9IGBIZXNhYsSxbsSxemRhICR7ZXJyb3JEYXRhLmJ1eWluZ19wb3dlciB8fCAnMCd9IFVTRCBhbMSxbSBnw7xjw7wgdmFyLiDEsMWfbGVtIGnDp2luICR7ZXJyb3JEYXRhLmNvc3RfYmFzaXMgfHwgJzAnfSBVU0QgZ2VyZWtpeW9yLiBMw7x0ZmVuIGhlc2FixLFuxLF6YSBwYXJhIHnDvGtsZXlpbi5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIDQuIEdlbmVsIGl6aW4gaGF0YXPEsVxuICAgICAgICBlbHNlIGlmIChlcnJvck1lc3NhZ2VMb3dlci5pbmNsdWRlcygnaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zJykgfHwgZXJyb3JNZXNzYWdlTG93ZXIuaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdBbHBhY2EgQVBJIGVyacWfaW0gaXpuaSB5b2suIEFQSSBrZXlcXCdsZXJpbml6aW4gZ2VyZWtsaSBpemlubGVyZSBzYWhpcCBvbGR1xJ91bmRhbiBlbWluIG9sdW4uJztcbiAgICAgICAgICBlcnJvckRldGFpbHMuZXJyb3IgPSAnRm9yYmlkZGVuIC0gSW5zdWZmaWNpZW50IHBlcm1pc3Npb25zJztcbiAgICAgICAgICBlcnJvckRldGFpbHMuc3VnZ2VzdGlvbiA9ICdCcm9rZXIgQVBJIGtleVxcJ2luaXpkZSB0cmFkaW5nIGl6aW5sZXJpbmluIGFrdGlmIG9sZHXEn3VuZGFuIGVtaW4gb2x1bi4gQWxwYWNhIEJyb2tlciBEYXNoYm9hcmRcXCdkYW4ga29udHJvbCBlZGluLic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gRGnEn2VyIDQwMyBoYXRhbGFyxLFcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYEFscGFjYSBBUEkgZXJpxZ9pbSBoYXRhc8SxOiAke2Vycm9yRGF0YS5tZXNzYWdlIHx8ICfEsMWfbGVtIHJlZGRlZGlsZGknfWA7XG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmVycm9yID0gZXJyb3JEYXRhLmVycm9yIHx8ICdGb3JiaWRkZW4nO1xuICAgICAgICAgIGVycm9yRGV0YWlscy5zdWdnZXN0aW9uID0gJ0zDvHRmZW4gaGVzYXAgYXlhcmxhcsSxbsSxesSxIHZlIEFQSSBrZXkgaXppbmxlcmluaXppIGtvbnRyb2wgZWRpbi4nO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBlcnJvckRldGFpbHMuYWNjb3VudElkID0gYWNjb3VudElkIHx8ICdOb3QgcHJvdmlkZWQnO1xuICAgICAgICBlcnJvckRldGFpbHMuYm9keSA9IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KS5zdWJzdHJpbmcoMCwgMjAwKSA6ICdObyBib2R5JztcbiAgICAgICAgZXJyb3JEZXRhaWxzLmFwaVJlc3BvbnNlID0gZXJyb3JEYXRhOyAvLyBBUEknZGVuIGdlbGVuIHRhbSByZXNwb25zZVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQWxwYWNhIEFQSSBlbmRwb2ludCBidWx1bmFtYWTEsS4gVVJMOiAke3VybH0sIEVuZHBvaW50OiAke2VuZHBvaW50fWA7XG4gICAgICAgIGVycm9yRGV0YWlscy5lcnJvciA9ICdFbmRwb2ludCBub3QgZm91bmQnO1xuICAgICAgICBlcnJvckRldGFpbHMuc3VnZ2VzdGlvbiA9ICdFbmRwb2ludCBVUkxcXCdpbmkgdmUgYWNjb3VudCBJRFxcJ3lpIGtvbnRyb2wgZWRpbi4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBBbHBhY2EgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gLSBVUkw6ICR7dXJsfWA7XG4gICAgICAgIGVycm9yRGV0YWlscy5lcnJvciA9IGVycm9yRGF0YS5lcnJvciB8fCBlcnJvckRhdGEubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG4gICAgICB9XG5cbiAgICAgIC8vIERldGF5bMSxIGhhdGEgYmlsZ2lsZXJpbmkgbG9nbGFcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FscGFjYSBBUEkgRXJyb3IgRGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvckRldGFpbHMsIG51bGwsIDIpKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FscGFjYSBBUEkgRXJyb3IgUmVzcG9uc2U6JywgZXJyb3JEYXRhKTtcbiAgICAgIFxuICAgICAgLy8gSGF0YSBtZXNhasSxbmEgZGV0YXlsYXLEsSBla2xlXG4gICAgICBjb25zdCBkZXRhaWxlZE1lc3NhZ2UgPSBgJHtlcnJvck1lc3NhZ2V9XFxuXFxuRGV0YXlsYXI6XFxuJHtKU09OLnN0cmluZ2lmeShlcnJvckRldGFpbHMsIG51bGwsIDIpfWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZGV0YWlsZWRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignQWxwYWNhIEFQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EgaGVzYXAgYmlsZ2lsZXJpbmkgZ2V0aXJpciAoQnJva2VyIEFQSSAtIGFjY291bnQgSUQgaWxlKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhQWNjb3VudChhY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8QWxwYWNhQWNjb3VudD4ge1xuICAvLyBCcm9rZXIgQVBJIGt1bGxhbiAodjEvYWNjb3VudHMve2FjY291bnRJZH0pICsgVHJhZGluZyBzbmFwc2hvdCAodjEvdHJhZGluZy9hY2NvdW50cy97YWNjb3VudElkfSlcbiAgY29uc3QgW2FjY291bnRSZXN1bHQsIHRyYWRpbmdSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICBhbHBhY2FSZXF1ZXN0KGBhY2NvdW50cy8ke2FjY291bnRJZH1gLCAnR0VUJywgdW5kZWZpbmVkLCB0cnVlKSxcbiAgICBhbHBhY2FSZXF1ZXN0KGB0cmFkaW5nL2FjY291bnRzLyR7YWNjb3VudElkfS9hY2NvdW50YCwgJ0dFVCcsIHVuZGVmaW5lZCwgdHJ1ZSksXG4gIF0pO1xuXG4gIGlmIChhY2NvdW50UmVzdWx0LnN0YXR1cyAhPT0gJ2Z1bGZpbGxlZCcgJiYgdHJhZGluZ1Jlc3VsdC5zdGF0dXMgIT09ICdmdWxmaWxsZWQnKSB7XG4gICAgdGhyb3cgYWNjb3VudFJlc3VsdC5yZWFzb24gfHwgdHJhZGluZ1Jlc3VsdC5yZWFzb24gfHwgbmV3IEVycm9yKCdBbHBhY2EgYWNjb3VudCBiaWxnaXNpIGFsxLFuYW1hZMSxJyk7XG4gIH1cblxuICBjb25zdCBiYXNlQWNjb3VudCA9IGFjY291bnRSZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyA/IGFjY291bnRSZXN1bHQudmFsdWUgOiBudWxsO1xuICBjb25zdCB0cmFkaW5nQWNjb3VudCA9IHRyYWRpbmdSZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyA/IHRyYWRpbmdSZXN1bHQudmFsdWUgOiBudWxsO1xuXG4gIGlmICghdHJhZGluZ0FjY291bnQpIHtcbiAgICByZXR1cm4gYmFzZUFjY291bnQgYXMgQWxwYWNhQWNjb3VudDtcbiAgfVxuXG4gIGNvbnN0IG1lcmdlZEFjY291bnQ6IGFueSA9IHtcbiAgICAuLi4oYmFzZUFjY291bnQgfHwge30pLFxuICAgIHJlYWxfdGltZV9zbmFwc2hvdDogdHJhZGluZ0FjY291bnQsXG4gIH07XG5cbiAgY29uc3QgcmVhbHRpbWVGaWVsZHMgPSBbXG4gICAgJ2Nhc2gnLFxuICAgICdidXlpbmdfcG93ZXInLFxuICAgICdlcXVpdHknLFxuICAgICdwb3J0Zm9saW9fdmFsdWUnLFxuICAgICdsb25nX21hcmtldF92YWx1ZScsXG4gICAgJ3Nob3J0X21hcmtldF92YWx1ZScsXG4gICAgJ2luaXRpYWxfbWFyZ2luJyxcbiAgICAnbWFpbnRlbmFuY2VfbWFyZ2luJyxcbiAgICAnbGFzdF9lcXVpdHknLFxuICAgICdtdWx0aXBsaWVyJyxcbiAgICAncGF0dGVybl9kYXlfdHJhZGVyJyxcbiAgICAnZGF5dHJhZGVfY291bnQnLFxuICAgICdzbWEnLFxuICAgICd0cmFkZV9jYXNoJyxcbiAgICAncmVndF9idXlpbmdfcG93ZXInLFxuICAgICdkYXl0cmFkZV9idXlpbmdfcG93ZXInLFxuICAgICdwZW5kaW5nX3RyYW5zZmVyX2luJyxcbiAgICAncGVuZGluZ190cmFuc2Zlcl9vdXQnLFxuICAgICdhY2NydWVkX2ZlZXMnLFxuICBdO1xuXG4gIHJlYWx0aW1lRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaWYgKHRyYWRpbmdBY2NvdW50W2ZpZWxkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXJnZWRBY2NvdW50W2ZpZWxkXSA9IHRyYWRpbmdBY2NvdW50W2ZpZWxkXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBtZXJnZWRBY2NvdW50IGFzIEFscGFjYUFjY291bnQ7XG59XG5cbi8qKlxuICogQWxwYWNhIHBvemlzeW9ubGFyxLEgZ2V0aXJpciAoQnJva2VyIEFQSSAtIGFjY291bnQgSUQgaWxlKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhUG9zaXRpb25zKGFjY291bnRJZDogc3RyaW5nKTogUHJvbWlzZTxBbHBhY2FQb3NpdGlvbltdPiB7XG4gIC8vIEJyb2tlciBBUEkga3VsbGFuICh2MS90cmFkaW5nL2FjY291bnRzL3thY2NvdW50SWR9L3Bvc2l0aW9ucylcbiAgcmV0dXJuIGFscGFjYVJlcXVlc3QoYHRyYWRpbmcvYWNjb3VudHMvJHthY2NvdW50SWR9L3Bvc2l0aW9uc2AsICdHRVQnLCB1bmRlZmluZWQsIHRydWUpO1xufVxuXG4vKipcbiAqIEFscGFjYSBzaXBhcmnFn2xlcmkgZ2V0aXJpclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhT3JkZXJzKHBhcmFtczoge1xuICBhY2NvdW50SWQ6IHN0cmluZzsgLy8gWm9ydW5sdTogTcO8xZ90ZXJpIGFjY291bnQgSUQnc2lcbiAgc3RhdHVzPzogc3RyaW5nO1xuICBsaW1pdD86IG51bWJlcjtcbiAgYWZ0ZXI/OiBzdHJpbmc7XG4gIHVudGlsPzogc3RyaW5nO1xuICBkaXJlY3Rpb24/OiBzdHJpbmc7XG4gIG5lc3RlZD86IGJvb2xlYW47XG59KTogUHJvbWlzZTxBbHBhY2FPcmRlcltdPiB7XG4gIGNvbnN0IHsgYWNjb3VudElkLCAuLi5xdWVyeVBhcmFtcyB9ID0gcGFyYW1zO1xuICBcbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIE9iamVjdC5lbnRyaWVzKHF1ZXJ5UGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBrZXkgIT09ICdhY2NvdW50SWQnKSB7XG4gICAgICBxdWVyeVN0cmluZy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gQnJva2VyIEFQSSBrdWxsYW4gKHYxL3RyYWRpbmcvYWNjb3VudHMve2FjY291bnRJZH0vb3JkZXJzKVxuICBjb25zdCBlbmRwb2ludCA9IGB0cmFkaW5nL2FjY291bnRzLyR7YWNjb3VudElkfS9vcmRlcnMke3F1ZXJ5U3RyaW5nLnRvU3RyaW5nKCkgPyAnPycgKyBxdWVyeVN0cmluZy50b1N0cmluZygpIDogJyd9YDtcbiAgcmV0dXJuIGFscGFjYVJlcXVlc3QoZW5kcG9pbnQsICdHRVQnLCB1bmRlZmluZWQsIHRydWUpO1xufVxuXG4vKipcbiAqIEFscGFjYSBwb3J0ZsO2eSBnZcOnbWnFn2kgZ2V0aXJpclxuICogTm90OiBCcm9rZXIgQVBJJ2RlIHBvcnRmb2xpbyBoaXN0b3J5IGVuZHBvaW50J2kgeW9rXG4gKiBCdSB5w7x6ZGVuIGFjY291bnQgYmlsZ2lsZXJpbmRlbiBwb3J0Zm9saW8gaGlzdG9yeSBvbHXFn3R1cnVsdXlvclxuICogQWNjb3VudCBiaWxnaWxlcmkgZXF1aXR5LCBwb3J0Zm9saW9fdmFsdWUsIGxhc3RfZXF1aXR5IGnDp2VyaXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFscGFjYVBvcnRmb2xpb0hpc3RvcnkocGFyYW1zOiB7XG4gIGFjY291bnRJZDogc3RyaW5nOyAvLyBCcm9rZXIgQVBJIGFjY291bnQgSURcbiAgcGVyaW9kPzogc3RyaW5nO1xuICB0aW1lZnJhbWU/OiBzdHJpbmc7XG4gIGVuZF9kYXRlPzogc3RyaW5nO1xufSk6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IHsgYWNjb3VudElkLCBwZXJpb2QgPSAnMU0nIH0gPSBwYXJhbXM7XG4gIFxuICAvLyBCcm9rZXIgQVBJJ2RlIHBvcnRmb2xpbyBoaXN0b3J5IGVuZHBvaW50J2kgeW9rXG4gIC8vIEJ1IHnDvHpkZW4gYWNjb3VudCBiaWxnaWxlcmluZGVuIHZlIHBvemlzeW9ubGFyZGFuIHBvcnRmb2xpbyBoaXN0b3J5IG9sdcWfdHVydXlvcnV6XG4gIHRyeSB7XG4gICAgLy8gQWNjb3VudCBiaWxnaXNpbmkgYWwgKGVxdWl0eSwgcG9ydGZvbGlvX3ZhbHVlLCBsYXN0X2VxdWl0eSBpw6dlcmlyKVxuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBnZXRBbHBhY2FBY2NvdW50KGFjY291bnRJZCk7XG4gICAgXG4gICAgLy8gUG96aXN5b25sYXLEsSBhbCAoa2FyL3phcmFyIGhlc2FwbGFtYWsgacOnaW4pXG4gICAgY29uc3QgcG9zaXRpb25zID0gYXdhaXQgZ2V0QWxwYWNhUG9zaXRpb25zKGFjY291bnRJZCk7XG4gICAgXG4gICAgY29uc3QgZXF1aXR5ID0gcGFyc2VGbG9hdChhY2NvdW50LmVxdWl0eSB8fCAnMCcpO1xuICAgIGNvbnN0IGxhc3RFcXVpdHkgPSBwYXJzZUZsb2F0KGFjY291bnQubGFzdF9lcXVpdHkgfHwgJzAnKTtcbiAgICBjb25zdCBwb3J0Zm9saW9WYWx1ZSA9IHBhcnNlRmxvYXQoYWNjb3VudC5wb3J0Zm9saW9fdmFsdWUgfHwgJzAnKTtcbiAgICBjb25zdCBjYXNoID0gcGFyc2VGbG9hdChhY2NvdW50LmNhc2ggfHwgYWNjb3VudC50cmFkZV9jYXNoIHx8ICcwJyk7XG4gICAgXG4gICAgLy8gUGVyaW9kJ2EgZ8O2cmUgZ8O8biBzYXnEsXPEsW7EsSBoZXNhcGxhXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBkYXlzQmFjayA9IDMwOyAvLyBEZWZhdWx0IDFNXG4gICAgaWYgKHBlcmlvZCA9PT0gJzFkJyB8fCBwZXJpb2QgPT09ICcxRCcpIGRheXNCYWNrID0gMTtcbiAgICBlbHNlIGlmIChwZXJpb2QgPT09ICcxVycpIGRheXNCYWNrID0gNztcbiAgICBlbHNlIGlmIChwZXJpb2QgPT09ICcxTScpIGRheXNCYWNrID0gMzA7XG4gICAgZWxzZSBpZiAocGVyaW9kID09PSAnM00nKSBkYXlzQmFjayA9IDkwO1xuICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gJzZNJykgZGF5c0JhY2sgPSAxODA7XG4gICAgZWxzZSBpZiAocGVyaW9kID09PSAnMVknKSBkYXlzQmFjayA9IDM2NTtcbiAgICBcbiAgICAvLyBHZcOnbWnFnyB2ZXJpbGVyaSBvbHXFn3R1ciAoc2ltw7xsZSBlZGlsbWnFnylcbiAgICBjb25zdCBoaXN0b3J5OiBhbnlbXSA9IFtdO1xuICAgIFxuICAgIC8vIEJhxZ9sYW5nxLHDpyBkZcSfZXJpIChsYXN0X2VxdWl0eSB2ZXlhIGVxdWl0eSdkZW4gdGFobWluKVxuICAgIGNvbnN0IHN0YXJ0RXF1aXR5ID0gbGFzdEVxdWl0eSA+IDAgPyBsYXN0RXF1aXR5IDogZXF1aXR5ICogMC45NTsgLy8gJTUgZMO8xZ/DvMWfIHZhcnNhecSxbcSxXG4gICAgXG4gICAgLy8gSGVyIGfDvG4gacOnaW4gYmlyIGthecSxdCBvbHXFn3R1clxuICAgIGZvciAobGV0IGkgPSBkYXlzQmFjazsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0b2RheSk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBpKTtcbiAgICAgIGRhdGUuc2V0SG91cnMoMTYsIDAsIDAsIDApOyAvLyBNYXJrZXQgY2xvc2UgdGltZVxuICAgICAgXG4gICAgICAvLyBCYXNpdCBiaXIgdHJlbmQgb2x1xZ90dXIgKGdlcsOnZWsgdmVyaSB5b2tzYSlcbiAgICAgIC8vIEVxdWl0eSdkZW4gYmHFn2xhecSxcCwgZ8O8bmzDvGsga8O8w6fDvGsgZGXEn2nFn2ltbGVybGUgaWxlcmxlXG4gICAgICBjb25zdCBwcm9ncmVzcyA9IChkYXlzQmFjayAtIGkpIC8gZGF5c0JhY2s7IC8vIDAnZGFuIDEnZVxuICAgICAgY29uc3QgZGFpbHlDaGFuZ2UgPSAoZXF1aXR5IC0gc3RhcnRFcXVpdHkpIC8gZGF5c0JhY2s7IC8vIEfDvG5sw7xrIG9ydGFsYW1hIGRlxJ9pxZ9pbVxuICAgICAgY29uc3QgdmFyaWFuY2UgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAoZXF1aXR5ICogMC4wMik7IC8vICUyIHZhcnlhbnNcbiAgICAgIGNvbnN0IGVzdGltYXRlZEVxdWl0eSA9IHN0YXJ0RXF1aXR5ICsgKGRhaWx5Q2hhbmdlICogKGRheXNCYWNrIC0gaSkpICsgdmFyaWFuY2U7XG4gICAgICBcbiAgICAgIC8vIFBvemlzeW9ubGFyZGFuIHRvcGxhbSBrYXIvemFyYXIgaGVzYXBsYSAodGFobWluaSlcbiAgICAgIGNvbnN0IHRvdGFsUG5MID0gcG9zaXRpb25zLnJlZHVjZSgoc3VtOiBudW1iZXIsIHBvczogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHVucmVhbGl6ZWRQTCA9IHBhcnNlRmxvYXQocG9zLnVucmVhbGl6ZWRfcGwgfHwgJzAnKTtcbiAgICAgICAgcmV0dXJuIHN1bSArIHVucmVhbGl6ZWRQTDtcbiAgICAgIH0sIDApO1xuICAgICAgXG4gICAgICAvLyBHw7xubMO8ayBrYXIvemFyYXIgdGFobWluaVxuICAgICAgY29uc3QgZGFpbHlQbkwgPSB0b3RhbFBuTCAvIGRheXNCYWNrO1xuICAgICAgY29uc3QgZXN0aW1hdGVkUG5MID0gZGFpbHlQbkwgKiAoZGF5c0JhY2sgLSBpKTtcbiAgICAgIFxuICAgICAgaGlzdG9yeS5wdXNoKHtcbiAgICAgICAgdGltZXN0YW1wOiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGVxdWl0eTogTWF0aC5tYXgoMCwgZXN0aW1hdGVkRXF1aXR5KSxcbiAgICAgICAgcHJvZml0X2xvc3M6IGVzdGltYXRlZFBuTCxcbiAgICAgICAgcHJvZml0X2xvc3NfcGN0OiBzdGFydEVxdWl0eSA+IDAgPyAoKGVzdGltYXRlZFBuTCAvIHN0YXJ0RXF1aXR5KSAqIDEwMCkgOiAwLFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNvbiBrYXnEsXQgZ2Vyw6dlayBkZcSfZXJsZXJsZSBnw7xuY2VsbGVuaXJcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsYXN0UmVjb3JkID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgbGFzdFJlY29yZC5lcXVpdHkgPSBlcXVpdHk7XG4gICAgICBsYXN0UmVjb3JkLnByb2ZpdF9sb3NzID0gZXF1aXR5IC0gc3RhcnRFcXVpdHk7XG4gICAgICBsYXN0UmVjb3JkLnByb2ZpdF9sb3NzX3BjdCA9IHN0YXJ0RXF1aXR5ID4gMCA/ICgoKGVxdWl0eSAtIHN0YXJ0RXF1aXR5KSAvIHN0YXJ0RXF1aXR5KSAqIDEwMCkgOiAwO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwcm9maXRMb3NzID0gZXF1aXR5IC0gbGFzdEVxdWl0eTtcbiAgICBjb25zdCBwcm9maXRMb3NzUGN0ID0gbGFzdEVxdWl0eSA+IDAgPyAoKHByb2ZpdExvc3MgLyBsYXN0RXF1aXR5KSAqIDEwMCkgOiAwO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBlcXVpdHk6IGVxdWl0eSxcbiAgICAgIHByb2ZpdF9sb3NzOiBwcm9maXRMb3NzLFxuICAgICAgcHJvZml0X2xvc3NfcGN0OiBwcm9maXRMb3NzUGN0LFxuICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignUG9ydGZvbGlvIGhpc3Rvcnkgb2x1xZ90dXJtYSBoYXRhc8SxOicsIGVycm9yKTtcbiAgICAvLyBIYXRhIGR1cnVtdW5kYSBib8WfIGhpc3RvcnkgZMO2bmTDvHJcbiAgICByZXR1cm4ge1xuICAgICAgZXF1aXR5OiAwLFxuICAgICAgcHJvZml0X2xvc3M6IDAsXG4gICAgICBwcm9maXRfbG9zc19wY3Q6IDAsXG4gICAgICBoaXN0b3J5OiBbXSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQWxwYWNhJ2RhIGhpc3NlIHNlbmVkaSBhbMSxbSBlbXJpIHZlcmlyIChCcm9rZXIgQVBJIC0gYWNjb3VudCBJRCBpbGUpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwbGFjZUJ1eU9yZGVyKGRhdGE6IHtcbiAgYWNjb3VudElkOiBzdHJpbmc7IC8vIFpvcnVubHU6IE3DvMWfdGVyaSBhY2NvdW50IElEJ3NpXG4gIHN5bWJvbDogc3RyaW5nO1xuICBxdHk/OiBudW1iZXI7XG4gIG5vdGlvbmFsPzogbnVtYmVyO1xuICBzaWRlOiAnYnV5JztcbiAgdHlwZTogJ21hcmtldCcgfCAnbGltaXQnIHwgJ3N0b3AnIHwgJ3N0b3BfbGltaXQnO1xuICB0aW1lX2luX2ZvcmNlOiAnZGF5JyB8ICdndGMnIHwgJ29wZycgfCAnY2xzJyB8ICdpb2MnIHwgJ2Zvayc7XG4gIGxpbWl0X3ByaWNlPzogbnVtYmVyO1xuICBzdG9wX3ByaWNlPzogbnVtYmVyO1xufSk6IFByb21pc2U8QWxwYWNhT3JkZXI+IHtcbiAgY29uc3QgeyBhY2NvdW50SWQsIC4uLm9yZGVyRGF0YSB9ID0gZGF0YTtcbiAgLy8gQnJva2VyIEFQSSBrdWxsYW4gKHYxL3RyYWRpbmcvYWNjb3VudHMve2FjY291bnRJZH0vb3JkZXJzKVxuICByZXR1cm4gYWxwYWNhUmVxdWVzdChgdHJhZGluZy9hY2NvdW50cy8ke2FjY291bnRJZH0vb3JkZXJzYCwgJ1BPU1QnLCBvcmRlckRhdGEsIHRydWUpO1xufVxuXG4vKipcbiAqIEFscGFjYSdkYSBoaXNzZSBzZW5lZGkgc2F0xLFtIGVtcmkgdmVyaXIgKEJyb2tlciBBUEkgLSBhY2NvdW50IElEIGlsZSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBsYWNlU2VsbE9yZGVyKGRhdGE6IHtcbiAgYWNjb3VudElkOiBzdHJpbmc7IC8vIFpvcnVubHU6IE3DvMWfdGVyaSBhY2NvdW50IElEJ3NpXG4gIHN5bWJvbDogc3RyaW5nO1xuICBxdHk/OiBudW1iZXI7XG4gIG5vdGlvbmFsPzogbnVtYmVyO1xuICBzaWRlOiAnc2VsbCc7XG4gIHR5cGU6ICdtYXJrZXQnIHwgJ2xpbWl0JyB8ICdzdG9wJyB8ICdzdG9wX2xpbWl0JztcbiAgdGltZV9pbl9mb3JjZTogJ2RheScgfCAnZ3RjJyB8ICdvcGcnIHwgJ2NscycgfCAnaW9jJyB8ICdmb2snO1xuICBsaW1pdF9wcmljZT86IG51bWJlcjtcbiAgc3RvcF9wcmljZT86IG51bWJlcjtcbn0pOiBQcm9taXNlPEFscGFjYU9yZGVyPiB7XG4gIGNvbnN0IHsgYWNjb3VudElkLCAuLi5vcmRlckRhdGEgfSA9IGRhdGE7XG4gIC8vIEJyb2tlciBBUEkga3VsbGFuICh2MS90cmFkaW5nL2FjY291bnRzL3thY2NvdW50SWR9L29yZGVycylcbiAgcmV0dXJuIGFscGFjYVJlcXVlc3QoYHRyYWRpbmcvYWNjb3VudHMvJHthY2NvdW50SWR9L29yZGVyc2AsICdQT1NUJywgb3JkZXJEYXRhLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBBbHBhY2Egc2lwYXJpxZ9pIGlwdGFsIGVkZXIgKEJyb2tlciBBUEkgLSBhY2NvdW50IElEIGlsZSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbmNlbEFscGFjYU9yZGVyKGFjY291bnRJZDogc3RyaW5nLCBvcmRlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gQnJva2VyIEFQSSBrdWxsYW4gKHYxL3RyYWRpbmcvYWNjb3VudHMve2FjY291bnRJZH0vb3JkZXJzL3tvcmRlcklkfSlcbiAgcmV0dXJuIGFscGFjYVJlcXVlc3QoYHRyYWRpbmcvYWNjb3VudHMvJHthY2NvdW50SWR9L29yZGVycy8ke29yZGVySWR9YCwgJ0RFTEVURScsIHVuZGVmaW5lZCwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQWxwYWNhJ2RhIG9wc2l5b24gcG96aXN5b25sYXLEsSBnZXRpcmlyIChCcm9rZXIgQVBJIC0gYWNjb3VudCBJRCBpbGUpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbHBhY2FPcHRpb25zUG9zaXRpb25zKGFjY291bnRJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICB0cnkge1xuICAgIC8vIEJyb2tlciBBUEknZGUgb3B0aW9ucyBpw6dpbiBhc3NldF9jbGFzcyBwYXJhbWV0cmVzaSBkZXN0ZWtsZW5taXlvclxuICAgIC8vIFTDvG0gcG9zaXRpb25zJ8SxIGFsIHZlIG9wdGlvbnMnbGFyxLEgZmlsdHJlbGVcbiAgICBjb25zdCBhbGxQb3NpdGlvbnMgPSBhd2FpdCBhbHBhY2FSZXF1ZXN0KGB0cmFkaW5nL2FjY291bnRzLyR7YWNjb3VudElkfS9wb3NpdGlvbnNgLCAnR0VUJywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBcbiAgICAvLyBPcHRpb25zIHBvemlzeW9ubGFyxLFuxLEgZmlsdHJlbGVcbiAgICAvLyBPcHRpb25zIGdlbmVsbGlrbGUgYXNzZXRfY2xhc3M9J29wdGlvbicgdmV5YSB1enVuIHNlbWJvbCBmb3JtYXTEsW5kYSBvbHVyXG4gICAgY29uc3Qgb3B0aW9uc1Bvc2l0aW9ucyA9IEFycmF5LmlzQXJyYXkoYWxsUG9zaXRpb25zKSBcbiAgICAgID8gYWxsUG9zaXRpb25zLmZpbHRlcigocG9zOiBhbnkpID0+IHtcbiAgICAgICAgICAvLyBhc3NldF9jbGFzcyBrb250cm9sw7xcbiAgICAgICAgICBpZiAocG9zLmFzc2V0X2NsYXNzID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN5bWJvbCBmb3JtYXTEsSBrb250cm9sw7wgKG9wdGlvbnMgZ2VuZWxsaWtsZSB1enVuIGZvcm1hdDogQUFQTDI0MDExOUMwMDE1MDAwMClcbiAgICAgICAgICBpZiAocG9zLnN5bWJvbCAmJiBwb3Muc3ltYm9sLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAvLyBPcHRpb25zIHNlbWJvbGxlcmkgZ2VuZWxsaWtsZSB0YXJpaCB2ZSBzdHJpa2UgcHJpY2UgacOnZXJpclxuICAgICAgICAgICAgLy8gRm9ybWF0OiBTWU1CT0wgKyBZWU1NREQgKyBDL1AgKyBTVFJJS0UgKMO2cm46IEFBUEwyNDAxMTlDMDAxNTAwMDApXG4gICAgICAgICAgICBjb25zdCBvcHRpb25QYXR0ZXJuID0gL15bQS1aXStcXGR7Nn1bQ1BdXFxkKyQvO1xuICAgICAgICAgICAgaWYgKG9wdGlvblBhdHRlcm4udGVzdChwb3Muc3ltYm9sKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgOiBbXTtcbiAgICBcbiAgICByZXR1cm4gb3B0aW9uc1Bvc2l0aW9ucztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIC8vIE9wdGlvbnMgZGVzdGVrbGVubWl5b3JzYSB2ZXlhIGhhdGEgdmFyc2EgYm/FnyBhcnJheSBkw7ZuZMO8ciAoc2Vzc2l6Y2UgaGFuZGxlIGV0KVxuICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW52YWxpZCBhc3NldF9jbGFzcycpIHx8IFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnNDA0JykgfHwgXG4gICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdub3QgZm91bmQnKSkge1xuICAgICAgY29uc29sZS53YXJuKCdPcHRpb25zIHBvc2l0aW9ucyBhbMSxbmFtYWTEsSwgYm/FnyBhcnJheSBkw7ZuZMO8csO8bMO8eW9yOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBEacSfZXIgaGF0YWxhciBpw6dpbiBkZSBib8WfIGFycmF5IGTDtm5kw7xyIChvcHRpb25zIG9wc2l5b25lbCBiaXIgw7Z6ZWxsaWspXG4gICAgY29uc29sZS53YXJuKCdPcHRpb25zIHBvc2l0aW9ucyBoYXRhc8SxIChpZ25vcmVkKTonLCBlcnJvci5tZXNzYWdlKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EnZGEgb3BzaXlvbiBlbXJpIHZlcmlyIChCcm9rZXIgQVBJIC0gYWNjb3VudCBJRCBpbGUpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwbGFjZU9wdGlvbnNPcmRlcihkYXRhOiB7XG4gIGFjY291bnRJZDogc3RyaW5nOyAvLyBab3J1bmx1OiBNw7zFn3RlcmkgYWNjb3VudCBJRCdzaSAoVVVJRCBmb3JtYXTEsW5kYSBvbG1hbMSxKVxuICBzeW1ib2w6IHN0cmluZzsgLy8gT3BzaXlvbiBzZW1ib2zDvCAow7ZybjogQUFQTDI0MDExOUMwMDE1MDAwMClcbiAgcXR5OiBudW1iZXI7XG4gIHNpZGU6ICdidXknIHwgJ3NlbGwnO1xuICB0eXBlOiAnbWFya2V0JyB8ICdsaW1pdCcgfCAnc3RvcCcgfCAnc3RvcF9saW1pdCc7XG4gIHRpbWVfaW5fZm9yY2U6ICdkYXknIHwgJ2d0YycgfCAnb3BnJyB8ICdjbHMnIHwgJ2lvYycgfCAnZm9rJztcbiAgbGltaXRfcHJpY2U/OiBudW1iZXI7XG4gIHN0b3BfcHJpY2U/OiBudW1iZXI7XG59KTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgeyBhY2NvdW50SWQsIC4uLm9yZGVyRGF0YSB9ID0gZGF0YTtcbiAgXG4gIC8vIEFjY291bnQgSUQgZG/En3J1bGFtYTogVVVJRCBmb3JtYXTEsW5kYSBvbG1hbMSxICjDtnJuOiBkMDA1Y2E2NS1hMzQwLTQzNzMtYjc4My00MWEwY2EzZDEzZjkpXG4gIC8vIEXEn2VyIHNhecSxc2FsIGJpciBkZcSfZXJzZSAoYWNjb3VudF9udW1iZXIpLCBoYXRhIHZlclxuICBpZiAoYWNjb3VudElkICYmIC9eXFxkKyQvLnRlc3QoYWNjb3VudElkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgR2XDp2Vyc2l6IGFjY291bnQgSUQgZm9ybWF0xLEuIFVVSUQgZm9ybWF0xLFuZGEgYmlyIGFjY291bnQgSUQgZ2VyZWtsaWRpciAow7ZybjogZDAwNWNhNjUtYTM0MC00MzczLWI3ODMtNDFhMGNhM2QxM2Y5KS4gQWzEsW5hbiBkZcSfZXI6ICR7YWNjb3VudElkfS4gTMO8dGZlbiBhY2NvdW50IElEIHllcmluZSBhY2NvdW50IFVVSUQga3VsbGFuxLFuLmApO1xuICB9XG4gIFxuICAvLyBCcm9rZXIgQVBJIGt1bGxhbiAodjEvdHJhZGluZy9hY2NvdW50cy97YWNjb3VudElkfS9vcmRlcnMpXG4gIHJldHVybiBhbHBhY2FSZXF1ZXN0KGB0cmFkaW5nL2FjY291bnRzLyR7YWNjb3VudElkfS9vcmRlcnNgLCAnUE9TVCcsIG9yZGVyRGF0YSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQWxwYWNhJ2RhIGtyaXB0byBwb3ppc3lvbmxhcsSxIGdldGlyaXIgKEJyb2tlciBBUEkgLSBhY2NvdW50IElEIGlsZSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFscGFjYUNyeXB0b1Bvc2l0aW9ucyhhY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcbiAgLy8gQnJva2VyIEFQSSBrdWxsYW4gKHYxL3RyYWRpbmcvYWNjb3VudHMve2FjY291bnRJZH0vcG9zaXRpb25zP2Fzc2V0X2NsYXNzPWNyeXB0bylcbiAgcmV0dXJuIGFscGFjYVJlcXVlc3QoYHRyYWRpbmcvYWNjb3VudHMvJHthY2NvdW50SWR9L3Bvc2l0aW9ucz9hc3NldF9jbGFzcz1jcnlwdG9gLCAnR0VUJywgdW5kZWZpbmVkLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBBbHBhY2EnZGEga3JpcHRvIGVtcmkgdmVyaXIgKEJyb2tlciBBUEkgLSBhY2NvdW50IElEIGlsZSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBsYWNlQ3J5cHRvT3JkZXIoZGF0YToge1xuICBhY2NvdW50SWQ6IHN0cmluZzsgLy8gWm9ydW5sdTogTcO8xZ90ZXJpIGFjY291bnQgSUQnc2lcbiAgc3ltYm9sOiBzdHJpbmc7IC8vIEtyaXB0byBzZW1ib2zDvCAow7ZybjogQlRDVVNELCBFVEhVU0QpXG4gIHF0eT86IG51bWJlcjtcbiAgbm90aW9uYWw/OiBudW1iZXI7XG4gIHNpZGU6ICdidXknIHwgJ3NlbGwnO1xuICB0eXBlOiAnbWFya2V0JyB8ICdsaW1pdCcgfCAnc3RvcCcgfCAnc3RvcF9saW1pdCc7XG4gIHRpbWVfaW5fZm9yY2U6ICdkYXknIHwgJ2d0YycgfCAnb3BnJyB8ICdjbHMnIHwgJ2lvYycgfCAnZm9rJztcbiAgbGltaXRfcHJpY2U/OiBudW1iZXI7XG4gIHN0b3BfcHJpY2U/OiBudW1iZXI7XG59KTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgeyBhY2NvdW50SWQsIC4uLm9yZGVyRGF0YSB9ID0gZGF0YTtcbiAgLy8gQnJva2VyIEFQSSBrdWxsYW4gKHYxL3RyYWRpbmcvYWNjb3VudHMve2FjY291bnRJZH0vb3JkZXJzKVxuICByZXR1cm4gYWxwYWNhUmVxdWVzdChgdHJhZGluZy9hY2NvdW50cy8ke2FjY291bnRJZH0vb3JkZXJzYCwgJ1BPU1QnLCBvcmRlckRhdGEsIHRydWUpO1xufVxuXG4vKipcbiAqIEFscGFjYSdkYSBzZW1ib2wgZml5YXQgYmlsZ2lzaSBnZXRpcmlyIChNYXJrZXQgRGF0YSBBUEkpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbHBhY2FRdW90ZShzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIC8vIE1hcmtldCBEYXRhIEFQSSBpw6dpbiBkaXJla3QgZmV0Y2ggeWFwXG4gIGNvbnN0IGVuZHBvaW50ID0gYHYyL3N0b2Nrcy8ke3N5bWJvbH0vcXVvdGVzL2xhdGVzdGA7XG4gIGNvbnN0IHVybCA9IGAke0FMUEFDQV9NQVJLRVRfREFUQV9VUkx9LyR7ZW5kcG9pbnR9YDtcbiAgXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgJ0FQQ0EtQVBJLUtFWS1JRCc6IEFMUEFDQV9NQVJLRVRfREFUQV9BUElfS0VZLFxuICAgICdBUENBLUFQSS1TRUNSRVQtS0VZJzogQUxQQUNBX01BUktFVF9EQVRBX1NFQ1JFVF9LRVksXG4gIH07XG5cbiAgLy8gUmV0cnkgbWVrYW5pem1hc8SxXG4gIGNvbnN0IGZldGNoV2l0aFJldHJ5ID0gYXN5bmMgKHJldHJpZXMgPSAzLCBkZWxheSA9IDUwMCk6IFByb21pc2U8UmVzcG9uc2U+ID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldHJpZXM7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGNvbnN0IGlzTmV0d29ya0Vycm9yID0gZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2ZldGNoIGZhaWxlZCcpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0VDT05OUkVTRVQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKTtcbiAgICAgICAgaWYgKGlzTmV0d29ya0Vycm9yICYmIGkgPCByZXRyaWVzIC0gMSkge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgIGRlbGF5ICo9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWF4IHJldHJ5IGxpbWl0IHJlYWNoZWQnKTtcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkoKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IH0pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgTWFya2V0IERhdGEgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignQWxwYWNhIFF1b3RlIEFQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EnZGEgc2VtYm9sIHNvbiBmaXlhdCBiaWxnaXNpIGdldGlyaXIgKE1hcmtldCBEYXRhIEFQSSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFscGFjYUxhdGVzdFRyYWRlKHN5bWJvbDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gTWFya2V0IERhdGEgQVBJIGnDp2luIGRpcmVrdCBmZXRjaCB5YXBcbiAgY29uc3QgZW5kcG9pbnQgPSBgdjIvc3RvY2tzLyR7c3ltYm9sfS90cmFkZXMvbGF0ZXN0YDtcbiAgY29uc3QgdXJsID0gYCR7QUxQQUNBX01BUktFVF9EQVRBX1VSTH0vJHtlbmRwb2ludH1gO1xuICBcbiAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAnQVBDQS1BUEktS0VZLUlEJzogQUxQQUNBX01BUktFVF9EQVRBX0FQSV9LRVksXG4gICAgJ0FQQ0EtQVBJLVNFQ1JFVC1LRVknOiBBTFBBQ0FfTUFSS0VUX0RBVEFfU0VDUkVUX0tFWSxcbiAgfTtcblxuICAvLyBSZXRyeSBtZWthbml6bWFzxLFcbiAgY29uc3QgZmV0Y2hXaXRoUmV0cnkgPSBhc3luYyAocmV0cmllcyA9IDMsIGRlbGF5ID0gNTAwKTogUHJvbWlzZTxSZXNwb25zZT4gPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc3QgaXNOZXR3b3JrRXJyb3IgPSBlcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZmV0Y2ggZmFpbGVkJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRUNPTk5SRVNFVCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbmV0d29yaycpO1xuICAgICAgICBpZiAoaXNOZXR3b3JrRXJyb3IgJiYgaSA8IHJldHJpZXMgLSAxKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgZGVsYXkgKj0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXggcmV0cnkgbGltaXQgcmVhY2hlZCcpO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSgpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQgfSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBNYXJrZXQgRGF0YSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbHBhY2EgTGF0ZXN0IFRyYWRlIEFQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EnZGEga3JpcHRvIGnDp2luIGVuIHNvbiB0cmFkZSB2ZXJpc2luaSBnZXRpcmlyIChNYXJrZXQgRGF0YSBBUEkpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbHBhY2FDcnlwdG9MYXRlc3RUcmFkZShzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIC8vIE1hcmtldCBEYXRhIEFQSSBpw6dpbiBkaXJla3QgZmV0Y2ggeWFwXG4gIGNvbnN0IGVuZHBvaW50ID0gYHYxYmV0YTMvY3J5cHRvLyR7c3ltYm9sfS90cmFkZXMvbGF0ZXN0YDtcbiAgY29uc3QgdXJsID0gYCR7QUxQQUNBX01BUktFVF9EQVRBX1VSTH0vJHtlbmRwb2ludH1gO1xuICBcbiAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAnQVBDQS1BUEktS0VZLUlEJzogQUxQQUNBX01BUktFVF9EQVRBX0FQSV9LRVksXG4gICAgJ0FQQ0EtQVBJLVNFQ1JFVC1LRVknOiBBTFBBQ0FfTUFSS0VUX0RBVEFfU0VDUkVUX0tFWSxcbiAgfTtcblxuICAvLyBSZXRyeSBtZWthbml6bWFzxLFcbiAgY29uc3QgZmV0Y2hXaXRoUmV0cnkgPSBhc3luYyAocmV0cmllcyA9IDMsIGRlbGF5ID0gNTAwKTogUHJvbWlzZTxSZXNwb25zZT4gPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc3QgaXNOZXR3b3JrRXJyb3IgPSBlcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZmV0Y2ggZmFpbGVkJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRUNPTk5SRVNFVCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbmV0d29yaycpO1xuICAgICAgICBpZiAoaXNOZXR3b3JrRXJyb3IgJiYgaSA8IHJldHJpZXMgLSAxKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgZGVsYXkgKj0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXggcmV0cnkgbGltaXQgcmVhY2hlZCcpO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSgpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQgfSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBDcnlwdG8gTWFya2V0IERhdGEgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignQWxwYWNhIENyeXB0byBMYXRlc3QgVHJhZGUgQVBJIEVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEFscGFjYSdkYSBvcHNpeW9uIHNlbWJvbMO8IGnDp2luIHF1b3RlIHZlcmlzaW5pIGdldGlyaXIgKE1hcmtldCBEYXRhIEFQSSAtIEhpc3RvcmljYWwgT3B0aW9uIERhdGEpXG4gKiBBbHBhY2EnbsSxbiBIaXN0b3JpY2FsIE9wdGlvbiBEYXRhIEFQSSdzaW5pIGt1bGxhbsSxclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhT3B0aW9uUXVvdGUob3B0aW9uU3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAvLyBBbHBhY2EgSGlzdG9yaWNhbCBPcHRpb24gRGF0YSBBUEkgZW5kcG9pbnRcbiAgLy8gdjFiZXRhMS9vcHRpb25zL3F1b3Rlcy9sYXRlc3QgZW5kcG9pbnQnaW5pIGt1bGxhblxuICBjb25zdCBlbmRwb2ludCA9IGB2MWJldGExL29wdGlvbnMvcXVvdGVzL2xhdGVzdD9zeW1ib2xzPSR7b3B0aW9uU3ltYm9sfWA7XG4gIGNvbnN0IHVybCA9IGAke0FMUEFDQV9NQVJLRVRfREFUQV9VUkx9LyR7ZW5kcG9pbnR9YDtcbiAgXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgJ0FQQ0EtQVBJLUtFWS1JRCc6IEFMUEFDQV9NQVJLRVRfREFUQV9BUElfS0VZLFxuICAgICdBUENBLUFQSS1TRUNSRVQtS0VZJzogQUxQQUNBX01BUktFVF9EQVRBX1NFQ1JFVF9LRVksXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAvLyA0MDQgdmV5YSA0MDAgKGludmFsaWQgc3ltYm9sKSBoYXRhbGFyxLEgacOnaW4gbnVsbCBkw7ZuZMO8ciAob3BzaXlvbiBtZXZjdXQgZGXEn2lsIHZleWEgZ2XDp2Vyc2l6IGZvcm1hdClcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IH0pKTtcbiAgICAgIC8vIEludmFsaWQgc3ltYm9sIGhhdGFzxLEgacOnaW4gbnVsbCBkw7ZuZMO8clxuICAgICAgaWYgKGVycm9yRGF0YS5tZXNzYWdlPy5pbmNsdWRlcygnaW52YWxpZCBzeW1ib2wnKSB8fCBlcnJvckRhdGEuY29kZSA9PT0gNDAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBPcHRpb24gUXVvdGUgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIC8vIFJlc3BvbnNlIGZvcm1hdDogeyBxdW90ZXM6IHsgU1lNQk9MOiB7Li4ufSB9IH1cbiAgICBpZiAoZGF0YS5xdW90ZXMgJiYgZGF0YS5xdW90ZXNbb3B0aW9uU3ltYm9sXSkge1xuICAgICAgcmV0dXJuIHsgcXVvdGU6IGRhdGEucXVvdGVzW29wdGlvblN5bWJvbF0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyA0MDQsIDQwMCB2ZXlhIGludmFsaWQgc3ltYm9sIGhhdGFsYXLEsSBvcHNpeW9udW4gbWV2Y3V0IG9sbWFkxLHEn8SxIHZleWEgZ2XDp2Vyc2l6IGZvcm1hdCBvbGR1xJ91IGFubGFtxLFuYSBnZWxpclxuICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnNDA0JykgfHwgXG4gICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdOb3QgRm91bmQnKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW52YWxpZCBzeW1ib2wnKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnY29kZT00MDAnKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0FscGFjYSBPcHRpb24gUXVvdGUgQVBJIEVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEFscGFjYSdkYSBvcHNpeW9uIHNlbWJvbMO8IGnDp2luIHRyYWRlIHZlcmlzaW5pIGdldGlyaXIgKE1hcmtldCBEYXRhIEFQSSAtIEhpc3RvcmljYWwgT3B0aW9uIERhdGEpXG4gKiBBbHBhY2EnbsSxbiBIaXN0b3JpY2FsIE9wdGlvbiBEYXRhIEFQSSdzaW5pIGt1bGxhbsSxclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhT3B0aW9uVHJhZGUob3B0aW9uU3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAvLyBBbHBhY2EgSGlzdG9yaWNhbCBPcHRpb24gRGF0YSBBUEkgZW5kcG9pbnRcbiAgLy8gdjFiZXRhMS9vcHRpb25zL3RyYWRlcy9sYXRlc3QgZW5kcG9pbnQnaW5pIGt1bGxhblxuICBjb25zdCBlbmRwb2ludCA9IGB2MWJldGExL29wdGlvbnMvdHJhZGVzL2xhdGVzdD9zeW1ib2xzPSR7b3B0aW9uU3ltYm9sfWA7XG4gIGNvbnN0IHVybCA9IGAke0FMUEFDQV9NQVJLRVRfREFUQV9VUkx9LyR7ZW5kcG9pbnR9YDtcbiAgXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgJ0FQQ0EtQVBJLUtFWS1JRCc6IEFMUEFDQV9NQVJLRVRfREFUQV9BUElfS0VZLFxuICAgICdBUENBLUFQSS1TRUNSRVQtS0VZJzogQUxQQUNBX01BUktFVF9EQVRBX1NFQ1JFVF9LRVksXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAvLyA0MDQgdmV5YSA0MDAgKGludmFsaWQgc3ltYm9sKSBoYXRhbGFyxLEgacOnaW4gbnVsbCBkw7ZuZMO8ciAob3BzaXlvbiBtZXZjdXQgZGXEn2lsIHZleWEgZ2XDp2Vyc2l6IGZvcm1hdClcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IH0pKTtcbiAgICAgIC8vIEludmFsaWQgc3ltYm9sIGhhdGFzxLEgacOnaW4gbnVsbCBkw7ZuZMO8clxuICAgICAgaWYgKGVycm9yRGF0YS5tZXNzYWdlPy5pbmNsdWRlcygnaW52YWxpZCBzeW1ib2wnKSB8fCBlcnJvckRhdGEuY29kZSA9PT0gNDAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBPcHRpb24gVHJhZGUgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIC8vIFJlc3BvbnNlIGZvcm1hdDogeyB0cmFkZXM6IHsgU1lNQk9MOiB7Li4ufSB9IH1cbiAgICBpZiAoZGF0YS50cmFkZXMgJiYgZGF0YS50cmFkZXNbb3B0aW9uU3ltYm9sXSkge1xuICAgICAgcmV0dXJuIHsgdHJhZGU6IGRhdGEudHJhZGVzW29wdGlvblN5bWJvbF0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyA0MDQsIDQwMCB2ZXlhIGludmFsaWQgc3ltYm9sIGhhdGFsYXLEsSBvcHNpeW9udW4gbWV2Y3V0IG9sbWFkxLHEn8SxIHZleWEgZ2XDp2Vyc2l6IGZvcm1hdCBvbGR1xJ91IGFubGFtxLFuYSBnZWxpclxuICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnNDA0JykgfHwgXG4gICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdOb3QgRm91bmQnKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW52YWxpZCBzeW1ib2wnKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnY29kZT00MDAnKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0FscGFjYSBPcHRpb24gVHJhZGUgQVBJIEVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEFscGFjYSdkYSBrcmlwdG8gacOnaW4gZ2XDp21pxZ8gZml5YXQgdmVyaWxlcmluaSAoYmFycykgZ2V0aXJpciAoTWFya2V0IERhdGEgQVBJKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhQ3J5cHRvQmFycyhcbiAgc3ltYm9sOiBzdHJpbmcsXG4gIHBhcmFtcz86IHtcbiAgICBzdGFydD86IHN0cmluZztcbiAgICBlbmQ/OiBzdHJpbmc7XG4gICAgdGltZWZyYW1lPzogJzFNaW4nIHwgJzVNaW4nIHwgJzE1TWluJyB8ICczME1pbicgfCAnMUhvdXInIHwgJzFEYXknIHwgJzFXZWVrJyB8ICcxTW9udGgnO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICB9XG4pOiBQcm9taXNlPGFueT4ge1xuICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgaWYgKHBhcmFtcykge1xuICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gQWxwYWNhIE1hcmtldCBEYXRhIEFQSSAtIENyeXB0b1xuICAvLyBDcnlwdG8gacOnaW4gZW5kcG9pbnQ6IHYxYmV0YTMvY3J5cHRvL2JhcnM/c3ltYm9scz17c3ltYm9sfVxuICAvLyBzeW1ib2xzIHBhcmFtZXRyZXNpIHpvcnVubHVkdXIgdmUgdGVrIGJpciBzZW1ib2wgb2xhcmFrIGfDtm5kZXJpbGlyXG4gIGNvbnN0IHRpbWVmcmFtZSA9IHBhcmFtcz8udGltZWZyYW1lIHx8ICcxRGF5JztcbiAgXG4gIC8vIFF1ZXJ5IHBhcmFtZXRyZWxlcmluaSBoYXrEsXJsYSAtIHN5bWJvbHMgcGFyYW1ldHJlc2kgaGVyIHphbWFuIGlsayBzxLFyYWRhIG9sbWFsxLFcbiAgcXVlcnlQYXJhbXMuc2V0KCdzeW1ib2xzJywgc3ltYm9sKTsgLy8gc3ltYm9scyBwYXJhbWV0cmVzaSB6b3J1bmx1XG4gIHF1ZXJ5UGFyYW1zLnNldCgndGltZWZyYW1lJywgdGltZWZyYW1lKTtcbiAgXG4gIGlmIChwYXJhbXM/LnN0YXJ0KSB7XG4gICAgcXVlcnlQYXJhbXMuc2V0KCdzdGFydCcsIHBhcmFtcy5zdGFydCk7XG4gIH1cbiAgaWYgKHBhcmFtcz8uZW5kKSB7XG4gICAgcXVlcnlQYXJhbXMuc2V0KCdlbmQnLCBwYXJhbXMuZW5kKTtcbiAgfVxuICBpZiAocGFyYW1zPy5saW1pdCkge1xuICAgIHF1ZXJ5UGFyYW1zLnNldCgnbGltaXQnLCBwYXJhbXMubGltaXQudG9TdHJpbmcoKSk7XG4gIH1cbiAgXG4gIC8vIHYxYmV0YTMvY3J5cHRvL2JhcnMgZW5kcG9pbnQnaW5pIGt1bGxhblxuICBjb25zdCBlbmRwb2ludCA9IGB2MWJldGEzL2NyeXB0by9iYXJzPyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gO1xuICBcbiAgLy8gTWFya2V0IGRhdGEgacOnaW4gw7Z6ZWwgVVJMIHZlIGtleSdsZXJcbiAgY29uc3QgdXJsID0gYCR7QUxQQUNBX01BUktFVF9EQVRBX1VSTH0vJHtlbmRwb2ludH1gO1xuICBcbiAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAnQVBDQS1BUEktS0VZLUlEJzogQUxQQUNBX01BUktFVF9EQVRBX0FQSV9LRVksXG4gICAgJ0FQQ0EtQVBJLVNFQ1JFVC1LRVknOiBBTFBBQ0FfTUFSS0VUX0RBVEFfU0VDUkVUX0tFWSxcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IH0pKTtcbiAgICAgIFxuICAgICAgLy8gQ3J5cHRvIGnDp2luIGRlIHN1YnNjcmlwdGlvbiBoYXRhc8SxIG9sYWJpbGlyXG4gICAgICBpZiAoZXJyb3JEYXRhLm1lc3NhZ2U/LmluY2x1ZGVzKCdzdWJzY3JpcHRpb24nKSB8fCBlcnJvckRhdGEubWVzc2FnZT8uaW5jbHVkZXMoJ1NJUCcpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ3J5cHRvIHN1YnNjcmlwdGlvbiBoYXRhc8SxOicsIGVycm9yRGF0YS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGV0YXlsxLEgaGF0YSBtZXNhasSxXG4gICAgICBjb25zdCBlcnJvck1zZyA9IGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBbHBhY2EgTWFya2V0IERhdGEgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0IHx8IGVycm9yTXNnLmluY2x1ZGVzKCdOb3QgRm91bmQnKSB8fCBlcnJvck1zZy5pbmNsdWRlcygnZW5kcG9pbnQgbm90IGZvdW5kJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDcnlwdG8gYmFycyBlbmRwb2ludCBidWx1bmFtYWTEsSAoJHtlbmRwb2ludH0pLiBBbHBhY2EgY3J5cHRvIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbifEsW7EsXrEsW4gYWt0aWYgb2xkdcSfdW5kYW4gdmUgQVBJIGtleSdsZXJpbml6aW4gY3J5cHRvIG1hcmtldCBkYXRhIGVyacWfaW1pbmUgc2FoaXAgb2xkdcSfdW5kYW4gZW1pbiBvbHVuLmApO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yTXNnLmluY2x1ZGVzKCdzeW1ib2xzJykgJiYgZXJyb3JNc2cuaW5jbHVkZXMoJ3JlcXVpcmVkJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDcnlwdG8gYmFycyBBUEkgaGF0YXPEsTogc3ltYm9scyBwYXJhbWV0cmVzaSBnZXJla2xpLiBFbmRwb2ludDogJHtlbmRwb2ludH0sIFN5bWJvbDogJHtzeW1ib2x9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgLy8gdjFiZXRhMyBlbmRwb2ludCdpIHsgYmFyczogeyBTWU1CT0w6IFsuLi5dIH0gfSBmb3JtYXTEsW5kYSBkw7ZuZXJcbiAgICBpZiAoZGF0YS5iYXJzICYmIHR5cGVvZiBkYXRhLmJhcnMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGRhdGEuYmFycykpIHtcbiAgICAgIC8vIHYxYmV0YTMgbXVsdGktc3ltYm9sIGZvcm1hdDogeyBiYXJzOiB7IFNZTUJPTDogWy4uLl0gfSB9XG4gICAgICBjb25zdCBzeW1ib2xCYXJzID0gZGF0YS5iYXJzW3N5bWJvbF0gfHwgW107XG4gICAgICByZXR1cm4geyBiYXJzOiBzeW1ib2xCYXJzIH07XG4gICAgfSBlbHNlIGlmIChkYXRhLmJhcnMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmJhcnMpKSB7XG4gICAgICAvLyBBcnJheSBmb3JtYXQ6IHsgYmFyczogWy4uLl0gfVxuICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjazogZGlyZWt0IGJhcnMgYXJyYXknaSBkw7ZuZMO8clxuICAgICAgcmV0dXJuIHsgYmFyczogZGF0YS5iYXJzIHx8IFtdIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignQWxwYWNhIENyeXB0byBCYXJzIEFQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcignRW5kcG9pbnQgVVJMOicsIHVybCk7XG4gICAgY29uc29sZS5lcnJvcignU3ltYm9sOicsIHN5bWJvbCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EnZGEgc2VtYm9sIGnDp2luIGdlw6dtacWfIGZpeWF0IHZlcmlsZXJpbmkgKGJhcnMpIGdldGlyaXIgKE1hcmtldCBEYXRhIEFQSSAtIFN0b2NrcylcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFscGFjYUJhcnMoXG4gIHN5bWJvbDogc3RyaW5nLFxuICBwYXJhbXM/OiB7XG4gICAgc3RhcnQ/OiBzdHJpbmc7XG4gICAgZW5kPzogc3RyaW5nO1xuICAgIHRpbWVmcmFtZT86ICcxTWluJyB8ICc1TWluJyB8ICcxNU1pbicgfCAnMzBNaW4nIHwgJzFIb3VyJyB8ICcxRGF5JyB8ICcxV2VlaycgfCAnMU1vbnRoJztcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgfVxuKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEFscGFjYSBNYXJrZXQgRGF0YSBBUEkgdjIgZW5kcG9pbnRcbiAgLy8gSUVYIGZlZWQga3VsbGFuICjDvGNyZXRzaXosIDE1IGRha2lrYSBnZWNpa21lbGkpIC0gU0lQIHN1YnNjcmlwdGlvbiBnZXJla3Rpcm1lelxuICBjb25zdCB0aW1lZnJhbWUgPSBwYXJhbXM/LnRpbWVmcmFtZSB8fCAnMURheSc7XG4gIHF1ZXJ5UGFyYW1zLnNldCgndGltZWZyYW1lJywgdGltZWZyYW1lKTtcbiAgcXVlcnlQYXJhbXMuc2V0KCdmZWVkJywgJ2lleCcpOyAvLyBJRVggZmVlZCBrdWxsYW4gKFNJUCB5ZXJpbmUpXG4gIFxuICBjb25zdCBlbmRwb2ludCA9IGB2Mi9zdG9ja3MvJHtzeW1ib2x9L2JhcnMke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCkgPyAnPycgKyBxdWVyeVBhcmFtcy50b1N0cmluZygpIDogJyd9YDtcbiAgXG4gIC8vIE1hcmtldCBkYXRhIGnDp2luIMO2emVsIFVSTCB2ZSBrZXknbGVyXG4gIGNvbnN0IHVybCA9IGAke0FMUEFDQV9NQVJLRVRfREFUQV9VUkx9LyR7ZW5kcG9pbnR9YDtcbiAgXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgJ0FQQ0EtQVBJLUtFWS1JRCc6IEFMUEFDQV9NQVJLRVRfREFUQV9BUElfS0VZLFxuICAgICdBUENBLUFQSS1TRUNSRVQtS0VZJzogQUxQQUNBX01BUktFVF9EQVRBX1NFQ1JFVF9LRVksXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCB9KSk7XG4gICAgICBcbiAgICAgIC8vIERhaGEgYcOnxLFrbGF5xLFjxLEgaGF0YSBtZXNhamxhcsSxXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXJrZXQgRGF0YSBBUEkga2ltbGlrIGRvxJ9ydWxhbWEgaGF0YXPEsS4gQVBJIGtleSdsZXJpbml6aSBrb250cm9sIGVkaW4uIFVSTDogJHt1cmx9LCBLZXk6ICR7QUxQQUNBX01BUktFVF9EQVRBX0FQSV9LRVk/LnN1YnN0cmluZygwLCAxMCl9Li4uYCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFya2V0IERhdGEgQVBJIGVyacWfaW0gaXpuaSB5b2suIEFQSSBrZXknbGVyaW5pemluIGdlcmVrbGkgaXppbmxlcmUgc2FoaXAgb2xkdcSfdW5kYW4gZW1pbiBvbHVuLmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFxJ9lciBTSVAgaGF0YXPEsSB2YXJzYSwgSUVYIGZlZWQgaWxlIHRla3JhciBkZW5lXG4gICAgICBpZiAoZXJyb3JEYXRhLm1lc3NhZ2U/LmluY2x1ZGVzKCdTSVAnKSB8fCBlcnJvckRhdGEubWVzc2FnZT8uaW5jbHVkZXMoJ3N1YnNjcmlwdGlvbicpKSB7XG4gICAgICAgIC8vIElFWCBmZWVkIHphdGVuIGVrbGVubWnFnywgYmHFn2thIGJpciBoYXRhIG9sYWJpbGlyXG4gICAgICAgIC8vIFZleWEgZGFoYSBlc2tpIHZlcmlsZXIgacOnaW4gZmFya2zEsSBiaXIgeWFrbGHFn8SxbSBkZW5lXG4gICAgICAgIGNvbnNvbGUud2FybignU0lQIHN1YnNjcmlwdGlvbiBoYXRhc8SxLCBJRVggZmVlZCBrdWxsYW7EsWzEsXlvcicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFscGFjYSBNYXJrZXQgRGF0YSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbHBhY2EgQmFycyBBUEkgRXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQnJva2VyIEFQSSdkZW4gdMO8bSBoZXNhcGxhcsSxIGdldGlyaXJcbiAqL1xuLyoqXG4gKiBBbHBhY2EnZGFuIG1hcmtldCBjbG9jayBiaWxnaXNpbmkgZ2V0aXJpciAocGl5YXNhIGHDp8Sxay9rYXBhbMSxIGR1cnVtdSB2ZSBzYWF0bGVyKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhTWFya2V0Q2xvY2soKTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlbmRwb2ludCA9ICd2Mi9jbG9jayc7XG4gICAgY29uc3QgdXJsID0gYCR7QUxQQUNBX0JBU0VfVVJMfS8ke2VuZHBvaW50fWA7XG4gICAgXG4gICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdBUENBLUFQSS1LRVktSUQnOiBBTFBBQ0FfQVBJX0tFWSxcbiAgICAgICdBUENBLUFQSS1TRUNSRVQtS0VZJzogQUxQQUNBX1NFQ1JFVF9LRVksXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWxwYWNhIE1hcmtldCBDbG9jayBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtlcnJvclRleHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0FscGFjYSBtYXJrZXQgY2xvY2sgZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQWxwYWNhJ2RhbiBtYXJrZXQgY2FsZW5kYXIgYmlsZ2lzaW5pIGdldGlyaXIgKHBpeWFzYSB0YWt2aW1pKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhTWFya2V0Q2FsZW5kYXIocGFyYW1zPzoge1xuICBzdGFydD86IHN0cmluZztcbiAgZW5kPzogc3RyaW5nO1xufSk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKHBhcmFtcz8uc3RhcnQpIHtcbiAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnc3RhcnQnLCBwYXJhbXMuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zPy5lbmQpIHtcbiAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnZW5kJywgcGFyYW1zLmVuZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1hcmtldCBDYWxlbmRhciBEYXRhIEFQSSdkZSBvbGFiaWxpciwgw7ZuY2UgRGF0YSBBUEkneWkgZGVuZVxuICAgIGNvbnN0IGVuZHBvaW50ID0gYHYxL2NhbGVuZGFyJHtxdWVyeVBhcmFtcy50b1N0cmluZygpID8gJz8nICsgcXVlcnlQYXJhbXMudG9TdHJpbmcoKSA6ICcnfWA7XG4gICAgXG4gICAgLy8gw5ZuY2UgRGF0YSBBUEkneWkgZGVuZVxuICAgIGxldCB1cmwgPSBgJHtBTFBBQ0FfTUFSS0VUX0RBVEFfVVJMfS8ke2VuZHBvaW50fWA7XG4gICAgbGV0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAnQVBDQS1BUEktS0VZLUlEJzogQUxQQUNBX01BUktFVF9EQVRBX0FQSV9LRVksXG4gICAgICAnQVBDQS1BUEktU0VDUkVULUtFWSc6IEFMUEFDQV9NQVJLRVRfREFUQV9TRUNSRVRfS0VZLFxuICAgIH07XG5cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pO1xuXG4gICAgLy8gRcSfZXIgRGF0YSBBUEknZGUgeW9rc2EsIFRyYWRpbmcgQVBJJ3lpIGRlbmVcbiAgICBpZiAoIXJlc3BvbnNlLm9rICYmIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICB1cmwgPSBgJHtBTFBBQ0FfQkFTRV9VUkx9LyR7ZW5kcG9pbnR9YDtcbiAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICdBUENBLUFQSS1LRVktSUQnOiBBTFBBQ0FfQVBJX0tFWSxcbiAgICAgICAgJ0FQQ0EtQVBJLVNFQ1JFVC1LRVknOiBBTFBBQ0FfU0VDUkVUX0tFWSxcbiAgICAgIH07XG5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAvLyA0MDQgaGF0YXPEsSBkdXJ1bXVuZGEgc2Vzc2l6Y2UgbnVsbCBkw7ZuZMO8ciAoZmFsbGJhY2sga3VsbGFuxLFsYWNhaylcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWxwYWNhIE1hcmtldCBDYWxlbmRhciBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtlcnJvclRleHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIC8vIDQwNCBoYXRhc8SxIGR1cnVtdW5kYSBzZXNzaXpjZSBudWxsIGTDtm5kw7xyIChmYWxsYmFjayBrdWxsYW7EsWxhY2FrKVxuICAgIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJzQwNCcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRGnEn2VyIGhhdGFsYXIgacOnaW4gc2FkZWNlIGRlYnVnIG1vZHVuZGEgbG9nbGFcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybignQWxwYWNhIG1hcmtldCBjYWxlbmRhciBlcnJvciAoZmFsbGJhY2sgd2lsbCBiZSB1c2VkKTonLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFscGFjYUFjY291bnRzKCk6IFByb21pc2U8YW55W10+IHtcbiAgLy8gQnJva2VyIEFQSSBrdWxsYW4gKHYxL2FjY291bnRzKVxuICByZXR1cm4gYWxwYWNhUmVxdWVzdCgnYWNjb3VudHMnLCAnR0VUJywgdW5kZWZpbmVkLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBBbHBhY2EnZGEgdMO8bSBha3RpZiB2YXJsxLFrbGFyxLEgKGFzc2V0cykgZ2V0aXJpclxuICogTm90OiBBc3NldHMgZW5kcG9pbnQnaSBUcmFkaW5nIEFQSSdkZSBvbGFiaWxpciwgYW5jYWsgTWFya2V0IERhdGEgQVBJIGtleSdsZXJpIGlsZSDDp2FsxLHFn21heWFiaWxpclxuICogQnUgecO8emRlbiDDtm5jZSBUcmFkaW5nIEFQSSd5aSBkZW5lLCBoYXRhIG9sdXJzYSBNYXJrZXQgRGF0YSBBUEkneWkgZGVuZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxwYWNhQXNzZXRzKHBhcmFtcz86IHtcbiAgc3RhdHVzPzogc3RyaW5nO1xuICBhc3NldF9jbGFzcz86IHN0cmluZztcbiAgZXhjaGFuZ2U/OiBzdHJpbmc7XG59KTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIEVuZHBvaW50J3RlIHYyLyBvbG1hbWFsxLEsIGFscGFjYVJlcXVlc3QgemF0ZW4gdjIvIGVrbGl5b3JcbiAgY29uc3QgZW5kcG9pbnQgPSBgYXNzZXRzJHtxdWVyeVBhcmFtcy50b1N0cmluZygpID8gJz8nICsgcXVlcnlQYXJhbXMudG9TdHJpbmcoKSA6ICcnfWA7XG4gIFxuICAvLyDDlm5jZSBUcmFkaW5nIEFQSSd5aSBkZW5lXG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGFscGFjYVJlcXVlc3QoZW5kcG9pbnQsICdHRVQnLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIC8vIFRyYWRpbmcgQVBJIGJhxZ9hcsSxc8SxeiBvbHVyc2EsIE1hcmtldCBEYXRhIEFQSSd5aSBkZW5lXG4gICAgY29uc29sZS53YXJuKCdUcmFkaW5nIEFQSSBhc3NldHMgZW5kcG9pbnQgZmFpbGVkLCB0cnlpbmcgTWFya2V0IERhdGEgQVBJOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIFxuICAgIC8vIE1hcmtldCBEYXRhIEFQSSBpw6dpbiBkaXJla3QgZmV0Y2ggeWFwXG4gICAgLy8gTWFya2V0IERhdGEgQVBJJ2RlIGVuZHBvaW50J2UgdjIvIGVrbGVubWVsaVxuICAgIGNvbnN0IG1hcmtldERhdGFFbmRwb2ludCA9IGB2Mi8ke2VuZHBvaW50fWA7XG4gICAgY29uc3QgdXJsID0gYCR7QUxQQUNBX01BUktFVF9EQVRBX1VSTH0vJHttYXJrZXREYXRhRW5kcG9pbnR9YDtcbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgJ0FQQ0EtQVBJLUtFWS1JRCc6IEFMUEFDQV9NQVJLRVRfREFUQV9BUElfS0VZLFxuICAgICAgJ0FQQ0EtQVBJLVNFQ1JFVC1LRVknOiBBTFBBQ0FfTUFSS0VUX0RBVEFfU0VDUkVUX0tFWSxcbiAgICB9O1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXJrZXQgRGF0YSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKG1hcmtldERhdGFFcnJvcjogYW55KSB7XG4gICAgICAvLyBIZXIgaWtpIEFQSSBkZSBiYcWfYXLEsXPEsXogb2x1cnNhIGhhdGF5xLEgZsSxcmxhdFxuICAgICAgY29uc29sZS5lcnJvcignQm90aCBUcmFkaW5nIEFQSSBhbmQgTWFya2V0IERhdGEgQVBJIGZhaWxlZCBmb3IgYXNzZXRzOicsIG1hcmtldERhdGFFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2V0cyBlbmRwb2ludCBtZXZjdXQgZGXEn2lsIHZleWEgQVBJIGtleSdsZXIgeWFubMSxxZ8geWFwxLFsYW5kxLFyxLFsbcSxxZ8uIFRyYWRpbmcgQVBJOiAke2Vycm9yLm1lc3NhZ2V9LCBNYXJrZXQgRGF0YSBBUEk6ICR7bWFya2V0RGF0YUVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWxwYWNhJ2RhIGhlc2FixLEga2FwYXTEsXIgKENMT1NFRCBkdXJ1bXVuYSBhbMSxcilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb3NlQWxwYWNhQWNjb3VudChhY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2xvc2VQYXlsb2FkID0ge1xuICAgICAgc3RhdHVzOiAnQ0xPU0VEJyxcbiAgICAgIHJlYXNvbjogJ0hlc2FwIGt1bGxhbsSxY8SxIHRhbGViaSDDvHplcmluZSBrYXBhdMSxbGTEsScsXG4gICAgfTtcbiAgICBcbiAgICAvLyBCcm9rZXIgQVBJIGt1bGxhbmFyYWsgaGVzYWLEsSBrYXBhdFxuICAgIHJldHVybiBhbHBhY2FSZXF1ZXN0KFxuICAgICAgYHRyYWRpbmcvYWNjb3VudHMvJHthY2NvdW50SWR9YCxcbiAgICAgICdQQVRDSCcsXG4gICAgICBjbG9zZVBheWxvYWQsXG4gICAgICB0cnVlLCAvLyB1c2VCcm9rZXJBUElcbiAgICAgIGFjY291bnRJZFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbHBhY2EgY2xvc2UgYWNjb3VudCBlcnJvcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EnZGEgeWVuaSB0cmFkaW5nIGhlc2FixLEgb2x1xZ90dXJ1ciAoQnJva2VyIEFQSSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFscGFjYUFjY291bnQoZGF0YToge1xuICBjb250YWN0OiB7XG4gICAgZW1haWxfYWRkcmVzczogc3RyaW5nO1xuICAgIHBob25lX251bWJlcj86IHN0cmluZztcbiAgICBzdHJlZXRfYWRkcmVzcz86IHN0cmluZ1tdO1xuICAgIGNpdHk/OiBzdHJpbmc7XG4gICAgc3RhdGU/OiBzdHJpbmc7XG4gICAgcG9zdGFsX2NvZGU/OiBzdHJpbmc7XG4gICAgY291bnRyeT86IHN0cmluZztcbiAgfTtcbiAgaWRlbnRpdHk6IHtcbiAgICBnaXZlbl9uYW1lOiBzdHJpbmc7XG4gICAgZmFtaWx5X25hbWU6IHN0cmluZztcbiAgICBkYXRlX29mX2JpcnRoPzogc3RyaW5nO1xuICAgIHRheF9pZD86IHN0cmluZztcbiAgICB0YXhfaWRfdHlwZT86ICdVU0FfU1NOJyB8ICdVU0FfSVRJTicgfCAnVVNBX0VJTicgfCAnTk9OX1VTQSc7XG4gICAgY291bnRyeV9vZl9jaXRpemVuc2hpcD86IHN0cmluZztcbiAgICBjb3VudHJ5X29mX2JpcnRoPzogc3RyaW5nO1xuICAgIGNvdW50cnlfb2ZfdGF4X3Jlc2lkZW5jZT86IHN0cmluZztcbiAgICBmdW5kaW5nX3NvdXJjZT86IHN0cmluZ1tdO1xuICB9O1xuICBkaXNjbG9zdXJlcz86IHtcbiAgICBpc19jb250cm9sX3BlcnNvbj86IGJvb2xlYW47XG4gICAgaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYT86IGJvb2xlYW47XG4gICAgaXNfcG9saXRpY2FsbHlfZXhwb3NlZD86IGJvb2xlYW47XG4gICAgaW1tZWRpYXRlX2ZhbWlseV9leHBvc2VkPzogYm9vbGVhbjtcbiAgfTtcbiAgYWdyZWVtZW50cz86IEFycmF5PHtcbiAgICBhZ3JlZW1lbnQ6IHN0cmluZztcbiAgICBzaWduZWRfYXQ/OiBzdHJpbmc7XG4gICAgaXBfYWRkcmVzcz86IHN0cmluZztcbiAgfT47XG4gIHRydXN0ZWRfY29udGFjdD86IHtcbiAgICBnaXZlbl9uYW1lPzogc3RyaW5nO1xuICAgIGZhbWlseV9uYW1lPzogc3RyaW5nO1xuICAgIGVtYWlsX2FkZHJlc3M/OiBzdHJpbmc7XG4gICAgcGhvbmVfbnVtYmVyPzogc3RyaW5nO1xuICAgIHN0cmVldF9hZGRyZXNzPzogc3RyaW5nW107XG4gICAgY2l0eT86IHN0cmluZztcbiAgICBzdGF0ZT86IHN0cmluZztcbiAgICBwb3N0YWxfY29kZT86IHN0cmluZztcbiAgICBjb3VudHJ5Pzogc3RyaW5nO1xuICB9O1xuICBlbmFibGVkX2Fzc2V0cz86IHN0cmluZ1tdOyAvLyBbJ3VzX2VxdWl0eScsICd1c19vcHRpb24nLCAnY3J5cHRvJ11cbn0pOiBQcm9taXNlPGFueT4ge1xuICBjb25zdCBhY2NvdW50UGF5bG9hZCA9IHtcbiAgICBjb250YWN0OiBkYXRhLmNvbnRhY3QsXG4gICAgaWRlbnRpdHk6IGRhdGEuaWRlbnRpdHksXG4gICAgLi4uKGRhdGEuZGlzY2xvc3VyZXMgJiYgeyBkaXNjbG9zdXJlczogZGF0YS5kaXNjbG9zdXJlcyB9KSxcbiAgICAuLi4oZGF0YS5hZ3JlZW1lbnRzICYmIHsgYWdyZWVtZW50czogZGF0YS5hZ3JlZW1lbnRzIH0pLFxuICAgIC4uLihkYXRhLnRydXN0ZWRfY29udGFjdCAmJiB7IHRydXN0ZWRfY29udGFjdDogZGF0YS50cnVzdGVkX2NvbnRhY3QgfSksXG4gICAgLi4uKGRhdGEuZW5hYmxlZF9hc3NldHMgJiYgeyBlbmFibGVkX2Fzc2V0czogZGF0YS5lbmFibGVkX2Fzc2V0cyB9KSxcbiAgfTtcbiAgXG4gIC8vIEJyb2tlciBBUEkga3VsbGFuICh2MS9hY2NvdW50cylcbiAgcmV0dXJuIGFscGFjYVJlcXVlc3QoJ2FjY291bnRzJywgJ1BPU1QnLCBhY2NvdW50UGF5bG9hZCwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQWxwYWNhIGhlc2FixLFuYSBwYXJhIHlhdMSxcsSxciAoZnVuZGluZy9kZXBvc2l0KVxuICogTm90OiBTYW5kYm94IG9ydGFtxLFuZGEgYnUgacWfbGVtIHPEsW7EsXJsxLEgb2xhYmlsaXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcG9zaXRUb0FscGFjYUFjY291bnQoZGF0YToge1xuICBhY2NvdW50SWQ6IHN0cmluZztcbiAgYW1vdW50OiBudW1iZXI7XG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xuICBub3Rlcz86IHN0cmluZztcbn0pOiBQcm9taXNlPGFueT4ge1xuICB0cnkge1xuICAgIC8vIEFscGFjYSBCcm9rZXIgQVBJJ2RlIGZ1bmRpbmcgZW5kcG9pbnQnaVxuICAgIC8vIE5vdDogU2FuZGJveCd0YSBidSBlbmRwb2ludCBzxLFuxLFybMSxIG9sYWJpbGlyLCBnZXLDp2VrIG9ydGFtZGEga3VsbGFuxLFsbWFsxLFcbiAgICBjb25zdCBmdW5kaW5nUGF5bG9hZCA9IHtcbiAgICAgIGFtb3VudDogZGF0YS5hbW91bnQudG9TdHJpbmcoKSxcbiAgICAgIGN1cnJlbmN5OiBkYXRhLmN1cnJlbmN5IHx8ICdVU0QnLFxuICAgICAgbm90ZXM6IGRhdGEubm90ZXMgfHwgYERlcG9zaXQgZnJvbSBNYW1idSBhY2NvdW50YCxcbiAgICB9O1xuICAgIFxuICAgIC8vIEJyb2tlciBBUEkga3VsbGFuICh2MS9hY2NvdW50cy97YWNjb3VudElkfS9mdW5kaW5nIHZleWEgYmVuemVyaSlcbiAgICAvLyBOb3Q6IEFscGFjYSduxLFuIGdlcsOnZWsgZnVuZGluZyBlbmRwb2ludCdpIGRva8O8bWFudGFzeW9uZGFuIGtvbnRyb2wgZWRpbG1lbGlcbiAgICAvLyDFnmltZGlsaWsgYWNjb3VudHMve2FjY291bnRJZH0gZW5kcG9pbnQnaW5lIFBPU1QgeWFwxLF5b3J1elxuICAgIHJldHVybiBhbHBhY2FSZXF1ZXN0KGBhY2NvdW50cy8ke2RhdGEuYWNjb3VudElkfS9mdW5kaW5nYCwgJ1BPU1QnLCBmdW5kaW5nUGF5bG9hZCwgdHJ1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbHBhY2EgZGVwb3NpdCBlcnJvcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EgaGVzYWLEsW5kYW4gcGFyYSDDp2VrZXIgKHdpdGhkcmF3YWwpXG4gKiBOb3Q6IFNhbmRib3ggb3J0YW3EsW5kYSBidSBpxZ9sZW0gc8SxbsSxcmzEsSBvbGFiaWxpclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aGRyYXdGcm9tQWxwYWNhQWNjb3VudChkYXRhOiB7XG4gIGFjY291bnRJZDogc3RyaW5nO1xuICBhbW91bnQ6IG51bWJlcjtcbiAgY3VycmVuY3k/OiBzdHJpbmc7XG4gIG5vdGVzPzogc3RyaW5nO1xufSk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgLy8gQWxwYWNhIEJyb2tlciBBUEknZGUgd2l0aGRyYXdhbCBlbmRwb2ludCdpXG4gICAgLy8gTm90OiBTYW5kYm94J3RhIGJ1IGVuZHBvaW50IHPEsW7EsXJsxLEgb2xhYmlsaXIsIGdlcsOnZWsgb3J0YW1kYSBrdWxsYW7EsWxtYWzEsVxuICAgIGNvbnN0IHdpdGhkcmF3YWxQYXlsb2FkID0ge1xuICAgICAgYW1vdW50OiBkYXRhLmFtb3VudC50b1N0cmluZygpLFxuICAgICAgY3VycmVuY3k6IGRhdGEuY3VycmVuY3kgfHwgJ1VTRCcsXG4gICAgICBub3RlczogZGF0YS5ub3RlcyB8fCBgV2l0aGRyYXdhbCB0byBNYW1idSBhY2NvdW50YCxcbiAgICB9O1xuICAgIFxuICAgIC8vIEJyb2tlciBBUEkga3VsbGFuICh2MS9hY2NvdW50cy97YWNjb3VudElkfS93aXRoZHJhd2FsIHZleWEgYmVuemVyaSlcbiAgICAvLyBOb3Q6IEFscGFjYSduxLFuIGdlcsOnZWsgd2l0aGRyYXdhbCBlbmRwb2ludCdpIGRva8O8bWFudGFzeW9uZGFuIGtvbnRyb2wgZWRpbG1lbGlcbiAgICByZXR1cm4gYWxwYWNhUmVxdWVzdChgYWNjb3VudHMvJHtkYXRhLmFjY291bnRJZH0vd2l0aGRyYXdhbGAsICdQT1NUJywgd2l0aGRyYXdhbFBheWxvYWQsIHRydWUpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignQWxwYWNhIHdpdGhkcmF3YWwgZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRW1haWwgaWxlIEFscGFjYSBoZXNhYsSxIGJ1bHVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kQWxwYWNhQWNjb3VudEJ5RW1haWwoZW1haWw6IHN0cmluZyk6IFByb21pc2U8YW55IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWxwYWNhQWNjb3VudHMoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWNjb3VudHMpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgYWNjb3VudCA9IGFjY291bnRzLmZpbmQoKGFjYzogYW55KSA9PiBcbiAgICAgIGFjYy5jb250YWN0Py5lbWFpbF9hZGRyZXNzID09PSBlbWFpbCB8fCBcbiAgICAgIGFjYy5lbWFpbCA9PT0gZW1haWwgfHxcbiAgICAgIGFjYy5lbWFpbF9hZGRyZXNzID09PSBlbWFpbFxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIGFjY291bnQgfHwgbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbmQgQWxwYWNhIGFjY291bnQgYnkgZW1haWwgZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQWxwYWNhJ2RhIGhlc2FwIGl6aW5sZXJpbmkgZ8O8bmNlbGxlciAob3BzaXlvbiB2ZSBrcmlwdG8pXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVBbHBhY2FBY2NvdW50UGVybWlzc2lvbnMoXG4gIGFjY291bnRJZDogc3RyaW5nLFxuICBwZXJtaXNzaW9uczoge1xuICAgIG9wdGlvbnNfZW5hYmxlZD86IGJvb2xlYW47XG4gICAgY3J5cHRvX2VuYWJsZWQ/OiBib29sZWFuO1xuICB9XG4pOiBQcm9taXNlPGFueT4ge1xuICB0cnkge1xuICAgIC8vIEFscGFjYSdkYSBpemluIGfDvG5jZWxsZW1lIGnDp2luIFBBVENIIGVuZHBvaW50J2kga3VsbGFuxLFsxLFyXG4gICAgLy8gZW5hYmxlZF9hc3NldHMgYXJyYXknaSBpbGUga29udHJvbCBlZGlsaXJcbiAgICBjb25zdCBjdXJyZW50QWNjb3VudCA9IGF3YWl0IGdldEFscGFjYUFjY291bnQoYWNjb3VudElkKTtcbiAgICBjb25zdCBjdXJyZW50QXNzZXRzID0gY3VycmVudEFjY291bnQ/LmVuYWJsZWRfYXNzZXRzIHx8IFtdO1xuICAgIFxuICAgIGNvbnN0IHVwZGF0ZWRBc3NldHMgPSBbLi4uY3VycmVudEFzc2V0c107XG4gICAgXG4gICAgLy8gT3BzaXlvbiBpem5pXG4gICAgaWYgKHBlcm1pc3Npb25zLm9wdGlvbnNfZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocGVybWlzc2lvbnMub3B0aW9uc19lbmFibGVkICYmICF1cGRhdGVkQXNzZXRzLmluY2x1ZGVzKCd1c19vcHRpb24nKSkge1xuICAgICAgICB1cGRhdGVkQXNzZXRzLnB1c2goJ3VzX29wdGlvbicpO1xuICAgICAgfSBlbHNlIGlmICghcGVybWlzc2lvbnMub3B0aW9uc19lbmFibGVkICYmIHVwZGF0ZWRBc3NldHMuaW5jbHVkZXMoJ3VzX29wdGlvbicpKSB7XG4gICAgICAgIHVwZGF0ZWRBc3NldHMuc3BsaWNlKHVwZGF0ZWRBc3NldHMuaW5kZXhPZigndXNfb3B0aW9uJyksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBLcmlwdG8gaXpuaVxuICAgIGlmIChwZXJtaXNzaW9ucy5jcnlwdG9fZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocGVybWlzc2lvbnMuY3J5cHRvX2VuYWJsZWQgJiYgIXVwZGF0ZWRBc3NldHMuaW5jbHVkZXMoJ2NyeXB0bycpKSB7XG4gICAgICAgIHVwZGF0ZWRBc3NldHMucHVzaCgnY3J5cHRvJyk7XG4gICAgICB9IGVsc2UgaWYgKCFwZXJtaXNzaW9ucy5jcnlwdG9fZW5hYmxlZCAmJiB1cGRhdGVkQXNzZXRzLmluY2x1ZGVzKCdjcnlwdG8nKSkge1xuICAgICAgICB1cGRhdGVkQXNzZXRzLnNwbGljZSh1cGRhdGVkQXNzZXRzLmluZGV4T2YoJ2NyeXB0bycpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgdXBkYXRlUGF5bG9hZCA9IHtcbiAgICAgIGVuYWJsZWRfYXNzZXRzOiB1cGRhdGVkQXNzZXRzLFxuICAgIH07XG4gICAgXG4gICAgLy8gQnJva2VyIEFQSSBrdWxsYW4gKHYxL2FjY291bnRzL3thY2NvdW50SWR9KVxuICAgIHJldHVybiBhbHBhY2FSZXF1ZXN0KGBhY2NvdW50cy8ke2FjY291bnRJZH1gLCAnUEFUQ0gnLCB1cGRhdGVQYXlsb2FkLCB0cnVlKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1VwZGF0ZSBBbHBhY2EgYWNjb3VudCBwZXJtaXNzaW9ucyBlcnJvcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbHBhY2EgQVBJIHlhcMSxbGFuZMSxcm1hc8SxbsSxIGtvbnRyb2wgZWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBbHBhY2FDb25maWd1cmVkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gISEoQUxQQUNBX0FQSV9LRVkgJiYgQUxQQUNBX1NFQ1JFVF9LRVkpO1xufVxuIl0sIm5hbWVzIjpbIkFMUEFDQV9BUElfS0VZIiwicHJvY2VzcyIsImVudiIsIkFMUEFDQV9TRUNSRVRfS0VZIiwiQUxQQUNBX0JBU0VfVVJMIiwiQUxQQUNBX0JST0tFUl9BUElfVVJMIiwiQUxQQUNBX0JST0tFUl9BUElfS0VZIiwiQUxQQUNBX0JST0tFUl9TRUNSRVRfS0VZIiwiQUxQQUNBX01BUktFVF9EQVRBX1VSTCIsIk5FWFRfUFVCTElDX0FMUEFDQV9EQVRBX0FQSV9VUkwiLCJBTFBBQ0FfTUFSS0VUX0RBVEFfQVBJX0tFWSIsIkFMUEFDQV9NQVJLRVRfQVBJX0tFWSIsIk5FWFRfUFVCTElDX0FMUEFDQV9NQVJLRVRfQVBJX0tFWSIsIkFMUEFDQV9NQVJLRVRfREFUQV9TRUNSRVRfS0VZIiwiQUxQQUNBX01BUktFVF9TRUNSRVRfS0VZIiwiTkVYVF9QVUJMSUNfQUxQQUNBX01BUktFVF9TRUNSRVRfS0VZIiwiYWxwYWNhUmVxdWVzdCIsImVuZHBvaW50IiwibWV0aG9kIiwiYm9keSIsInVzZUJyb2tlckFQSSIsImFjY291bnRJZCIsImJhc2VVcmwiLCJhcGlLZXkiLCJzZWNyZXRLZXkiLCJ2ZXJzaW9uIiwiZmluYWxFbmRwb2ludCIsInN0YXJ0c1dpdGgiLCJ1cmwiLCJoZWFkZXJzIiwiZmV0Y2hXaXRoUmV0cnkiLCJyZXRyaWVzIiwiZGVsYXkiLCJpIiwicmVzcG9uc2UiLCJmZXRjaCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJlcnJvciIsImlzTmV0d29ya0Vycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsInN0YXR1c1RleHQiLCJlcnJvck1lc3NhZ2UiLCJlcnJvckRldGFpbHMiLCJzdGF0dXMiLCJhcGlUeXBlIiwiYXBpS2V5UHJlZml4Iiwic3Vic3RyaW5nIiwic3VnZ2VzdGlvbiIsImVycm9yTWVzc2FnZUxvd2VyIiwidG9Mb3dlckNhc2UiLCJlcnJvckNvZGUiLCJwZHRJbmZvIiwicmVhc29uIiwic29sdXRpb24iLCJyZXN0cmljdGlvbiIsImJ1eWluZ1Bvd2VyIiwiYnV5aW5nX3Bvd2VyIiwiY29zdEJhc2lzIiwiY29zdF9iYXNpcyIsImFwaVJlc3BvbnNlIiwiZGV0YWlsZWRNZXNzYWdlIiwiZ2V0QWxwYWNhQWNjb3VudCIsImFjY291bnRSZXN1bHQiLCJ0cmFkaW5nUmVzdWx0IiwiYWxsU2V0dGxlZCIsImJhc2VBY2NvdW50IiwidmFsdWUiLCJ0cmFkaW5nQWNjb3VudCIsIm1lcmdlZEFjY291bnQiLCJyZWFsX3RpbWVfc25hcHNob3QiLCJyZWFsdGltZUZpZWxkcyIsImZvckVhY2giLCJmaWVsZCIsImdldEFscGFjYVBvc2l0aW9ucyIsImdldEFscGFjYU9yZGVycyIsInBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwicXVlcnlTdHJpbmciLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwiYXBwZW5kIiwidG9TdHJpbmciLCJnZXRBbHBhY2FQb3J0Zm9saW9IaXN0b3J5IiwicGVyaW9kIiwiYWNjb3VudCIsInBvc2l0aW9ucyIsImVxdWl0eSIsInBhcnNlRmxvYXQiLCJsYXN0RXF1aXR5IiwibGFzdF9lcXVpdHkiLCJwb3J0Zm9saW9WYWx1ZSIsInBvcnRmb2xpb192YWx1ZSIsImNhc2giLCJ0cmFkZV9jYXNoIiwidG9kYXkiLCJEYXRlIiwiZGF5c0JhY2siLCJoaXN0b3J5Iiwic3RhcnRFcXVpdHkiLCJkYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJzZXRIb3VycyIsInByb2dyZXNzIiwiZGFpbHlDaGFuZ2UiLCJ2YXJpYW5jZSIsIk1hdGgiLCJyYW5kb20iLCJlc3RpbWF0ZWRFcXVpdHkiLCJ0b3RhbFBuTCIsInJlZHVjZSIsInN1bSIsInBvcyIsInVucmVhbGl6ZWRQTCIsInVucmVhbGl6ZWRfcGwiLCJkYWlseVBuTCIsImVzdGltYXRlZFBuTCIsInB1c2giLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsIm1heCIsInByb2ZpdF9sb3NzIiwicHJvZml0X2xvc3NfcGN0IiwibGVuZ3RoIiwibGFzdFJlY29yZCIsInByb2ZpdExvc3MiLCJwcm9maXRMb3NzUGN0IiwicGxhY2VCdXlPcmRlciIsImRhdGEiLCJvcmRlckRhdGEiLCJwbGFjZVNlbGxPcmRlciIsImNhbmNlbEFscGFjYU9yZGVyIiwib3JkZXJJZCIsImdldEFscGFjYU9wdGlvbnNQb3NpdGlvbnMiLCJhbGxQb3NpdGlvbnMiLCJvcHRpb25zUG9zaXRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsdGVyIiwiYXNzZXRfY2xhc3MiLCJzeW1ib2wiLCJvcHRpb25QYXR0ZXJuIiwidGVzdCIsInBsYWNlT3B0aW9uc09yZGVyIiwiZ2V0QWxwYWNhQ3J5cHRvUG9zaXRpb25zIiwicGxhY2VDcnlwdG9PcmRlciIsImdldEFscGFjYVF1b3RlIiwiZ2V0QWxwYWNhTGF0ZXN0VHJhZGUiLCJnZXRBbHBhY2FDcnlwdG9MYXRlc3RUcmFkZSIsImdldEFscGFjYU9wdGlvblF1b3RlIiwib3B0aW9uU3ltYm9sIiwicXVvdGVzIiwicXVvdGUiLCJnZXRBbHBhY2FPcHRpb25UcmFkZSIsInRyYWRlcyIsInRyYWRlIiwiZ2V0QWxwYWNhQ3J5cHRvQmFycyIsInRpbWVmcmFtZSIsInNldCIsInN0YXJ0IiwiZW5kIiwibGltaXQiLCJlcnJvck1zZyIsImJhcnMiLCJzeW1ib2xCYXJzIiwiZ2V0QWxwYWNhQmFycyIsImdldEFscGFjYU1hcmtldENsb2NrIiwiZXJyb3JUZXh0IiwidGV4dCIsImdldEFscGFjYU1hcmtldENhbGVuZGFyIiwiZ2V0QWxwYWNhQWNjb3VudHMiLCJnZXRBbHBhY2FBc3NldHMiLCJtYXJrZXREYXRhRW5kcG9pbnQiLCJtYXJrZXREYXRhRXJyb3IiLCJjbG9zZUFscGFjYUFjY291bnQiLCJjbG9zZVBheWxvYWQiLCJjcmVhdGVBbHBhY2FBY2NvdW50IiwiYWNjb3VudFBheWxvYWQiLCJjb250YWN0IiwiaWRlbnRpdHkiLCJkaXNjbG9zdXJlcyIsImFncmVlbWVudHMiLCJ0cnVzdGVkX2NvbnRhY3QiLCJlbmFibGVkX2Fzc2V0cyIsImRlcG9zaXRUb0FscGFjYUFjY291bnQiLCJmdW5kaW5nUGF5bG9hZCIsImFtb3VudCIsImN1cnJlbmN5Iiwibm90ZXMiLCJ3aXRoZHJhd0Zyb21BbHBhY2FBY2NvdW50Iiwid2l0aGRyYXdhbFBheWxvYWQiLCJmaW5kQWxwYWNhQWNjb3VudEJ5RW1haWwiLCJlbWFpbCIsImFjY291bnRzIiwiZmluZCIsImFjYyIsImVtYWlsX2FkZHJlc3MiLCJ1cGRhdGVBbHBhY2FBY2NvdW50UGVybWlzc2lvbnMiLCJwZXJtaXNzaW9ucyIsImN1cnJlbnRBY2NvdW50IiwiY3VycmVudEFzc2V0cyIsInVwZGF0ZWRBc3NldHMiLCJvcHRpb25zX2VuYWJsZWQiLCJzcGxpY2UiLCJpbmRleE9mIiwiY3J5cHRvX2VuYWJsZWQiLCJ1cGRhdGVQYXlsb2FkIiwiaXNBbHBhY2FDb25maWd1cmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/alpaca.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&page=%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Falpaca%2Fcrypto%2Flatest%2Froute.ts&appDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Femretutkun%2FDocuments%2FGitHub%2F101010&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();